<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Specifications in Mocha</title>
  <meta name="generator" content="Mocha &lt;https://mochajs.org/&gt;" />
  <meta name="license" content="MIT" />
  <meta name="copyright" content="&#169; 2016 Kevin Locke &lt;kevin@kevinlocke.name&gt;" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css" integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r" crossorigin="anonymous" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/highlight.js/9.1.0/styles/github.min.css" />
  <style type="text/css">
section section {
  margin-left: 1em;
}
section section section section {
  margin-left: 0;
}
  </style>
</head>
<body>
  <div class="container">
    <section class="suite">
      <h1>appveyorStatus</h1>
      <dl>
        <section class="suite">
          <h1>.getLastBuild</h1>
          <dl>
            <section class="suite">
              <h1>with wait</h1>
              <dl>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>.getStatusBadge</h1>
          <dl>
          </dl>
        </section>
        <section class="suite">
          <h1>.getStatus</h1>
          <dl>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>appveyor-status command</h1>
      <dl>
        <dt>returns undefined when called with a function</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once()
  .withArgs(
    match.object,
    match.func
  );
const result = appveyorStatusCmd(RUNTIME_ARGS, sinon.mock().never());
appveyorStatusMock.verify();
assert.strictEqual(result, undefined);</code></pre></dd>
        <dt>prints error and exits for --badge</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for -B</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --badge foo as match(statusBadgeId: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -B foo as match(statusBadgeId: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --branch as match(branch: true)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -b as match(branch: true)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --branch foo as match(branch: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -b foo as match(branch: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets  as match(color: false)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --color as match(color: true)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --no-color as match(color: false)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --commit as match(commit: HEAD)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -c as match(commit: HEAD)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --commit foo as match(commit: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --commit 123 as match(commit: 123)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -c foo as match(commit: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for --help</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for -h</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for -?</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for --project</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for -p</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --project foo as match(project: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -p foo as match(project: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --quiet as match(verbosity: -1)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -q as match(verbosity: -1)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -qq as match(verbosity: -2)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --quiet -q as match(verbosity: -2)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for --repo</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for -r</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --repo foo as match(repo: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -r foo as match(repo: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for --token</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for -t</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets  as match(token: env-token)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --token foo as match(token: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -t foo as match(token: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for --token-file</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for -T</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --token-file /home/kevin/src/node-projects/appveyor-status/test-data/token.txt as match(token: file-token)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -T /home/kevin/src/node-projects/appveyor-status/test-data/token.txt as match(token: file-token)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for --token-file badfile</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for -T badfile</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --verbose as match(verbosity: 1)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -v as match(verbosity: 1)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -vv as match(verbosity: 2)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --verbose -v as match(verbosity: 2)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --wait as match(wait: Infinity)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -w as match(wait: Infinity)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --wait 10 as match(wait: 10000)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -w 10 as match(wait: 10000)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for --wait foo</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for -w foo</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for --webhook</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for -W</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --webhook foo as match(webhookId: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -W foo as match(webhookId: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for -t foo -T bar</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -q -v as match(verbosity: 0)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -v -q as match(verbosity: 0)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -v -q -v as match(verbosity: 1)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for --version</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for -V</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for foo</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -T - as reading token from stdin</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    match({token: &#x27;file-token&#x27;}),
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(&#x27;-T&#x27;, &#x27;-&#x27;);
options.in = fs.createReadStream(TEST_TOKEN_PATH);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>exits with code 2 for build cancelled</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});</code></pre></dd>
        <dt>exits with code 2 for build cancelling</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});</code></pre></dd>
        <dt>exits with code 2 for build failed</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});</code></pre></dd>
        <dt>exits with code 2 for build queued</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});</code></pre></dd>
        <dt>exits with code 2 for build running</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});</code></pre></dd>
        <dt>exits with code 0 for build success</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});</code></pre></dd>
        <dt>exits with code 2 for build unrecognized</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});</code></pre></dd>
        <dt>prints status to stdout by default</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, &#x27;success&#x27;);
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 0);
  assert.strictEqual(
    String(options.out.read()),
    // Be strict about this format since other programs may use it
    &#x27;AppVeyor build status: success\n&#x27;
  );
  assert.strictEqual(options.err.read(), null);
  done();
});</code></pre></dd>
        <dt>prints cancelled in gray to TTY</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
options.out.isTTY = true;
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, status === &#x27;success&#x27; ? 0 : 2);
  const outString = String(options.out.read());
  assert.include(
    outString,
    chalk[colorName](status)
  );
  assert.strictEqual(options.err.read(), null);
  done();
});</code></pre></dd>
        <dt>prints cancelling in gray to TTY</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
options.out.isTTY = true;
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, status === &#x27;success&#x27; ? 0 : 2);
  const outString = String(options.out.read());
  assert.include(
    outString,
    chalk[colorName](status)
  );
  assert.strictEqual(options.err.read(), null);
  done();
});</code></pre></dd>
        <dt>prints failed in red to TTY</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
options.out.isTTY = true;
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, status === &#x27;success&#x27; ? 0 : 2);
  const outString = String(options.out.read());
  assert.include(
    outString,
    chalk[colorName](status)
  );
  assert.strictEqual(options.err.read(), null);
  done();
});</code></pre></dd>
        <dt>prints queued in gray to TTY</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
options.out.isTTY = true;
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, status === &#x27;success&#x27; ? 0 : 2);
  const outString = String(options.out.read());
  assert.include(
    outString,
    chalk[colorName](status)
  );
  assert.strictEqual(options.err.read(), null);
  done();
});</code></pre></dd>
        <dt>prints running in gray to TTY</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
options.out.isTTY = true;
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, status === &#x27;success&#x27; ? 0 : 2);
  const outString = String(options.out.read());
  assert.include(
    outString,
    chalk[colorName](status)
  );
  assert.strictEqual(options.err.read(), null);
  done();
});</code></pre></dd>
        <dt>prints success in green to TTY</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
options.out.isTTY = true;
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, status === &#x27;success&#x27; ? 0 : 2);
  const outString = String(options.out.read());
  assert.include(
    outString,
    chalk[colorName](status)
  );
  assert.strictEqual(options.err.read(), null);
  done();
});</code></pre></dd>
        <dt>-q exits without printing status</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, &#x27;failed&#x27;);
const allArgs = RUNTIME_ARGS.concat(arg);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 2);
  assert.strictEqual(options.out.read(), null);
  assert.strictEqual(options.err.read(), null);
  done();
});</code></pre></dd>
        <dt>--quiet exits without printing status</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, &#x27;failed&#x27;);
const allArgs = RUNTIME_ARGS.concat(arg);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 2);
  assert.strictEqual(options.out.read(), null);
  assert.strictEqual(options.err.read(), null);
  done();
});</code></pre></dd>
        <dt>allows callback errors to propagate</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const errTest = new Error(&#x27;test&#x27;);
let caughtError = false;
let called = false;
// Note:  Chai assert.throws does not accept comparison function like node
try {
  const allArgs = RUNTIME_ARGS.concat([&#x27;foo&#x27;]);
  appveyorStatusCmd(allArgs, options, () =&#x3E; {
    assert(!called, &#x27;callback called exactly once&#x27;);
    called = true;
    throw errTest;
  });
} catch (err) {
  caughtError = true;
  assert.strictEqual(err, errTest);
}
assert(caughtError, &#x27;Missing expected exception.&#x27;);</code></pre></dd>
        <dt>throws for non-function callback</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
assert.throws(
  () =&#x3E; { appveyorStatusCmd(RUNTIME_ARGS, {}, true); },
  TypeError,
  /\bcallback\b/
);</code></pre></dd>
        <dt>can be called without arguments</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once()
  .withArgs(
    match.object,
    match.func
  );
appveyorStatusCmd(null, sinon.mock().never());
appveyorStatusMock.verify();</code></pre></dd>
        <dt>yields TypeError for non-Array-like args</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
appveyorStatusCmd(true, options, (err) =&#x3E; {
  assert.instanceOf(err, TypeError);
  assert.match(err.message, /\bArray\b/);
  done();
});</code></pre></dd>
        <dt>yields RangeError for less than 2 args</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
appveyorStatusCmd([], options, (err) =&#x3E; {
  assert.instanceOf(err, RangeError);
  assert.match(err.message, /\bargs\b/);
  done();
});</code></pre></dd>
        <dt>yields Error for non-object options</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
appveyorStatusCmd(RUNTIME_ARGS, true, (err) =&#x3E; {
  assert.instanceOf(err, TypeError);
  assert.match(err.message, /\boptions\b/);
  done();
});</code></pre></dd>
        <dt>yields Error for non-Readable in</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
appveyorStatusCmd(RUNTIME_ARGS, {in: true}, (err) =&#x3E; {
  assert.instanceOf(err, TypeError);
  assert.match(err.message, /\boptions.in\b/);
  done();
});</code></pre></dd>
        <dt>yields Error for non-Writable out</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const badOptions = {out: new stream.Readable()};
appveyorStatusCmd(RUNTIME_ARGS, badOptions, (err) =&#x3E; {
  assert.instanceOf(err, TypeError);
  assert.match(err.message, /\boptions.out\b/);
  done();
});</code></pre></dd>
        <dt>yields Error for non-Writable err</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const badOptions = {err: new stream.Readable()};
appveyorStatusCmd(RUNTIME_ARGS, badOptions, (err) =&#x3E; {
  assert.instanceOf(err, TypeError);
  assert.match(err.message, /\boptions.err\b/);
  done();
});</code></pre></dd>
        <dt>exit code 1 and prints message on Error</dt>
        <dd><pre><code>const errMsg = &#x27;super duper test error&#x27;;
appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(new Error(errMsg));
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 1);
  assert.strictEqual(options.out.read(), null);
  const errString = String(options.err.read());
  assert.include(errString, errMsg);
  done();
});</code></pre></dd>
        <dt>exit code 3 and prints message on CommitMismatchError</dt>
        <dd><pre><code>const testCommit = &#x27;123&#x27;;
const errTest = new CommitMismatchError({
  actual: &#x27;foo&#x27;,
  expected: testCommit
});
appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(errTest);
const allArgs = RUNTIME_ARGS.concat([&#x27;-c&#x27;, testCommit]);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 3);
  assert.strictEqual(options.out.read(), null);
  const errString = String(options.err.read());
  assert.include(errString, errTest.actual);
  assert.include(errString, errTest.expected);
  done();
});</code></pre></dd>
        <dt>CommitMismatchError prints both given and resolved</dt>
        <dd><pre><code>const testCommit = &#x27;123&#x27;;
const testTag = &#x27;tagname&#x27;;
const errTest = new CommitMismatchError({
  actual: &#x27;abc&#x27;,
  expected: testCommit
});
appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(errTest);
const allArgs = RUNTIME_ARGS.concat([&#x27;-c&#x27;, testTag]);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 3);
  assert.strictEqual(options.out.read(), null);
  const errString = String(options.err.read());
  assert.include(errString, errTest.actual);
  assert.include(errString, errTest.expected);
  assert.include(errString, testTag);
  done();
});</code></pre></dd>
        <dt>returns a Promise when called without a function</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func);
const result = appveyorStatusCmd(RUNTIME_ARGS);
assert(result instanceof Promise);</code></pre></dd>
        <dt>returned Promise is resolved with exit code</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, &#x27;success&#x27;);
const result = appveyorStatusCmd(RUNTIME_ARGS, options);
return result.then((code) =&#x3E; {
  assert.strictEqual(code, 0);
});</code></pre></dd>
        <dt>returned Promise is rejected with Error</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const result = appveyorStatusCmd(RUNTIME_ARGS, true);
return result.then(
  sinon.mock().never(),
  (err) =&#x3E; { assert.instanceOf(err, TypeError); }
);</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>AmbiguousProjectError</h1>
      <dl>
        <dt>sets .message and .projects from arguments</dt>
        <dd><pre><code>const testMsg = &#x27;test message&#x27;;
const testProjects = [];
const a = new AmbiguousProjectError(testMsg, testProjects);
assert.strictEqual(a.message, testMsg);
assert.strictEqual(a.projects, testProjects);</code></pre></dd>
        <dt>can be instantiated without arguments</dt>
        <dd><pre><code>const a = new AmbiguousProjectError();
assert(a.message, &#x27;has default message&#x27;);
assert.strictEqual(a.projects, undefined);</code></pre></dd>
        <dt>can be instantiated without new</dt>
        <dd><pre><code>const testMsg = &#x27;test message&#x27;;
const testProjects = [];
const a = AmbiguousProjectError(testMsg, testProjects);
assert(a instanceof AmbiguousProjectError);
assert.strictEqual(a.message, testMsg);
assert.strictEqual(a.projects, testProjects);</code></pre></dd>
        <dt>inherits from Error</dt>
        <dd><pre><code>const testMsg = &#x27;test message&#x27;;
const testProjects = [];
const a = new AmbiguousProjectError(testMsg, testProjects);
assert(a instanceof Error);</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>appveyorUtils</h1>
      <dl>
        <section class="suite">
          <h1>.badgeToStatus</h1>
          <dl>
            <dt>extracts success status</dt>
            <dd><pre><code>const badge = apiResponses.getStatusBadge(status);
const result = appveyorUtils.badgeToStatus(badge);
assert.strictEqual(result, status);</code></pre></dd>
            <dt>extracts failed status</dt>
            <dd><pre><code>const badge = apiResponses.getStatusBadge(status);
const result = appveyorUtils.badgeToStatus(badge);
assert.strictEqual(result, status);</code></pre></dd>
            <dt>throws for unrecognized status</dt>
            <dd><pre><code>const badge = apiResponses.getStatusBadge(&#x27;whatever&#x27;);
assert.throws(
  () =&#x3E; { appveyorUtils.badgeToStatus(badge); },
  Error
);</code></pre></dd>
            <dt>throws for ambiguous status</dt>
            <dd><pre><code>const badge = apiResponses.getStatusBadge(&#x27;success failed&#x27;);
assert.throws(
  () =&#x3E; { appveyorUtils.badgeToStatus(badge); },
  Error
);</code></pre></dd>
            <dt>throws for non-string</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; { appveyorUtils.badgeToStatus(null); },
  Error
);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.projectBuildToStatus</h1>
          <dl>
            <dt>returns any status of ProjectBuild</dt>
            <dd><pre><code>const testStatus = &#x27;foo&#x27;;
const projectBuild = apiResponses.getProjectBuild({status: testStatus});
const result = appveyorUtils.projectBuildToStatus(projectBuild);
assert.strictEqual(result, testStatus);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.parseAppveyorRepoUrl</h1>
          <dl>
            <dt>parses bitBucket HTTPS URL</dt>
            <dd><pre><code>const testProject = &#x27;foo/bar&#x27;;
const testUrl = &#x60;https://bitbucket.org/${testProject}.git&#x60;;
deepStrictEqual(
  appveyorUtils.parseAppveyorRepoUrl(testUrl),
  {
    repositoryType: &#x27;bitBucket&#x27;,
    repositoryName: testProject
  }
);</code></pre></dd>
            <dt>parses bitBucket SSH URL</dt>
            <dd><pre><code>const testProject = &#x27;foo/bar&#x27;;
const testUrl = &#x60;git@bitbucket.org:${testProject}.git&#x60;;
deepStrictEqual(
  appveyorUtils.parseAppveyorRepoUrl(testUrl),
  {
    repositoryType: &#x27;bitBucket&#x27;,
    repositoryName: testProject
  }
);</code></pre></dd>
            <dt>parses gitHub HTTPS URL</dt>
            <dd><pre><code>const testProject = &#x27;foo/bar&#x27;;
const testUrl = &#x60;https://github.com/${testProject}.git&#x60;;
deepStrictEqual(
  appveyorUtils.parseAppveyorRepoUrl(testUrl),
  {
    repositoryType: &#x27;gitHub&#x27;,
    repositoryName: testProject
  }
);</code></pre></dd>
            <dt>parses gitHub SSH URL</dt>
            <dd><pre><code>const testProject = &#x27;foo/bar&#x27;;
const testUrl = &#x60;git@github.com:${testProject}.git&#x60;;
deepStrictEqual(
  appveyorUtils.parseAppveyorRepoUrl(testUrl),
  {
    repositoryType: &#x27;gitHub&#x27;,
    repositoryName: testProject
  }
);</code></pre></dd>
            <dt>parses gitLab HTTPS URL</dt>
            <dd><pre><code>const testProject = &#x27;foo/bar&#x27;;
const testUrl = &#x60;https://gitlab.com/${testProject}.git&#x60;;
deepStrictEqual(
  appveyorUtils.parseAppveyorRepoUrl(testUrl),
  {
    repositoryType: &#x27;gitLab&#x27;,
    repositoryName: testProject
  }
);</code></pre></dd>
            <dt>parses gitLab SSH URL</dt>
            <dd><pre><code>const testProject = &#x27;foo/bar&#x27;;
const testUrl = &#x60;git@gitlab.com:${testProject}.git&#x60;;
deepStrictEqual(
  appveyorUtils.parseAppveyorRepoUrl(testUrl),
  {
    repositoryType: &#x27;gitLab&#x27;,
    repositoryName: testProject
  }
);</code></pre></dd>
            <dt>parses vso project git HTTPS URL</dt>
            <dd><pre><code>const testUrl = &#x27;https://kevinoid.visualstudio.com/_git/TestProj&#x27;;
deepStrictEqual(
  appveyorUtils.parseAppveyorRepoUrl(testUrl),
  {
    repositoryType: &#x27;vso&#x27;,
    repositoryName: &#x27;git/kevinoid/TestProj/TestProj&#x27;
  }
);</code></pre></dd>
            <dt>parses vso project git SSH URL</dt>
            <dd><pre><code>const testUrl =
  &#x27;ssh://kevinoid@kevinoid.visualstudio.com:22/_git/TestProj&#x27;;
deepStrictEqual(
  appveyorUtils.parseAppveyorRepoUrl(testUrl),
  {
    repositoryType: &#x27;vso&#x27;,
    repositoryName: &#x27;git/kevinoid/TestProj/TestProj&#x27;
  }
);</code></pre></dd>
            <dt>parses vso sub-project git HTTPS URL</dt>
            <dd><pre><code>const testUrl = &#x27;https://kevinoid.visualstudio.com/TestProj/_git/repo2&#x27;;
deepStrictEqual(
  appveyorUtils.parseAppveyorRepoUrl(testUrl),
  {
    repositoryType: &#x27;vso&#x27;,
    repositoryName: &#x27;git/kevinoid/TestProj/repo2&#x27;
  }
);</code></pre></dd>
            <dt>parses vso sub-project git SSH URL</dt>
            <dd><pre><code>const testUrl =
  &#x27;ssh://kevinoid@kevinoid.visualstudio.com:22/TestProj/_git/repo2&#x27;;
deepStrictEqual(
  appveyorUtils.parseAppveyorRepoUrl(testUrl),
  {
    repositoryType: &#x27;vso&#x27;,
    repositoryName: &#x27;git/kevinoid/TestProj/repo2&#x27;
  }
);</code></pre></dd>
            <dt>returns unknown HTTPS URL</dt>
            <dd><pre><code>const testUrl = &#x27;https://example.com/foo.git&#x27;;
deepStrictEqual(
  appveyorUtils.parseAppveyorRepoUrl(testUrl),
  {repositoryName: testUrl}
);</code></pre></dd>
            <dt>returns unknown SCP-like URL</dt>
            <dd><pre><code>const testUrl = &#x27;user@example.com:foo.git&#x27;;
deepStrictEqual(
  appveyorUtils.parseAppveyorRepoUrl(testUrl),
  {repositoryName: testUrl}
);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.repoUrlToBadgeParams</h1>
          <dl>
            <dt>parses bitBucket HTTPS URL</dt>
            <dd><pre><code>const testAccount = &#x27;foo&#x27;;
const testProject = &#x27;bar&#x27;;
const testUrl =
  &#x60;https://bitbucket.org/${testAccount}/${testProject}.git&#x60;;
deepStrictEqual(
  appveyorUtils.repoUrlToBadgeParams(testUrl),
  {
    badgeRepoProvider: &#x27;bitBucket&#x27;,
    repoAccountName: testAccount,
    repoSlug: testProject
  }
);</code></pre></dd>
            <dt>parses bitBucket SSH URL</dt>
            <dd><pre><code>const testAccount = &#x27;foo&#x27;;
const testProject = &#x27;bar&#x27;;
const testUrl =
  &#x60;git@bitbucket.org:${testAccount}/${testProject}.git&#x60;;
deepStrictEqual(
  appveyorUtils.repoUrlToBadgeParams(testUrl),
  {
    badgeRepoProvider: &#x27;bitBucket&#x27;,
    repoAccountName: testAccount,
    repoSlug: testProject
  }
);</code></pre></dd>
            <dt>throws for bitBucket URL with 3 path parts</dt>
            <dd><pre><code>const testUrl = &#x27;https://bitbucket.org/foo/bar/baz.git&#x27;;
assert.throws(
  () =&#x3E; { appveyorUtils.repoUrlToBadgeParams(testUrl); },
  Error
);</code></pre></dd>
            <dt>parses gitHub HTTPS URL</dt>
            <dd><pre><code>const testAccount = &#x27;foo&#x27;;
const testProject = &#x27;bar&#x27;;
const testUrl =
  &#x60;https://github.com/${testAccount}/${testProject}.git&#x60;;
deepStrictEqual(
  appveyorUtils.repoUrlToBadgeParams(testUrl),
  {
    badgeRepoProvider: &#x27;gitHub&#x27;,
    repoAccountName: testAccount,
    repoSlug: testProject
  }
);</code></pre></dd>
            <dt>parses gitHub SSH URL</dt>
            <dd><pre><code>const testAccount = &#x27;foo&#x27;;
const testProject = &#x27;bar&#x27;;
const testUrl =
  &#x60;git@github.com:${testAccount}/${testProject}.git&#x60;;
deepStrictEqual(
  appveyorUtils.repoUrlToBadgeParams(testUrl),
  {
    badgeRepoProvider: &#x27;gitHub&#x27;,
    repoAccountName: testAccount,
    repoSlug: testProject
  }
);</code></pre></dd>
            <dt>throws for gitLab HTTPS URL</dt>
            <dd><pre><code>const testUrl = &#x27;https://gitlab.com/foo/bar.git&#x27;;
assert.throws(
  () =&#x3E; { appveyorUtils.repoUrlToBadgeParams(testUrl); },
  Error
);</code></pre></dd>
            <dt>throws for gitLab HTTPS URL</dt>
            <dd><pre><code>const testUrl = &#x27;git@gitlab.com:foo/bar.git&#x27;;
assert.throws(
  () =&#x3E; { appveyorUtils.repoUrlToBadgeParams(testUrl); },
  Error
);</code></pre></dd>
            <dt>throws for vso HTTPS URL</dt>
            <dd><pre><code>const testUrl = &#x27;https://kevinoid.visualstudio.com/_git/TestProj&#x27;;
assert.throws(
  () =&#x3E; { appveyorUtils.repoUrlToBadgeParams(testUrl); },
  Error
);</code></pre></dd>
            <dt>throws for vso SSH URL</dt>
            <dd><pre><code>const testUrl =
  &#x27;ssh://kevinoid@kevinoid.visualstudio.com:22/_git/TestProj&#x27;;
assert.throws(
  () =&#x3E; { appveyorUtils.repoUrlToBadgeParams(testUrl); },
  Error
);</code></pre></dd>
            <dt>throws for other git HTTPS URLs</dt>
            <dd><pre><code>const testUrl = &#x27;https://example.com/foo.git&#x27;;
assert.throws(
  () =&#x3E; { appveyorUtils.repoUrlToBadgeParams(testUrl); },
  Error
);</code></pre></dd>
            <dt>returns unknown git SSH URL</dt>
            <dd><pre><code>const testUrl = &#x27;user@example.com:foo.git&#x27;;
assert.throws(
  () =&#x3E; { appveyorUtils.repoUrlToBadgeParams(testUrl); },
  Error
);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.projectFromString</h1>
          <dl>
            <dt>splits account name and slug to object</dt>
            <dd><pre><code>const accountName = &#x27;foo&#x27;;
const slug = &#x27;bar&#x27;;
deepStrictEqual(
  appveyorUtils.projectFromString(&#x60;${accountName}/${slug}&#x60;),
  {
    accountName,
    slug
  }
);</code></pre></dd>
            <dt>throws for string with 1 path part</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; { appveyorUtils.projectFromString(&#x27;foo&#x27;); },
  Error
);</code></pre></dd>
            <dt>throws for string with 3 path part</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; { appveyorUtils.projectFromString(&#x27;foo/bar/baz&#x27;); },
  Error
);</code></pre></dd>
            <dt>throws for non-string</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; { appveyorUtils.projectFromString(null); },
  Error
);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.projectToString</h1>
          <dl>
            <dt>joins account name and slug</dt>
            <dd><pre><code>const testProj = {
  accountName: &#x27;foo&#x27;,
  slug: &#x27;bar&#x27;
};
deepStrictEqual(
  appveyorUtils.projectToString(testProj),
  &#x27;foo/bar&#x27;
);</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>CommitMismatchError</h1>
      <dl>
        <dt>sets .actual and .expected from arguments</dt>
        <dd><pre><code>const testOptions = {
  actual: &#x27;abc&#x27;,
  expected: &#x27;123&#x27;
};
const err = new CommitMismatchError(testOptions);
assert.strictEqual(err.actual, testOptions.actual);
assert.strictEqual(err.expected, testOptions.expected);
assert.strictEqual(err.operator, &#x27;===&#x27;);
assert(
  err.message.indexOf(testOptions.actual) &#x3E;= 0,
  &#x27;constructs message with actual&#x27;
);
assert(
  err.message.indexOf(testOptions.expected) &#x3E;= 0,
  &#x27;constructs message with expected&#x27;
);</code></pre></dd>
        <dt>can set .message from arguments</dt>
        <dd><pre><code>const testOptions = {
  actual: &#x27;abc&#x27;,
  expected: &#x27;123&#x27;,
  message: &#x27;test&#x27;
};
const err = new CommitMismatchError(testOptions);
assert.strictEqual(err.actual, testOptions.actual);
assert.strictEqual(err.expected, testOptions.expected);
assert.strictEqual(err.operator, &#x27;===&#x27;);
assert.strictEqual(err.message, testOptions.message);</code></pre></dd>
        <dt>can be instantiated without new</dt>
        <dd><pre><code>const testOptions = {
  actual: &#x27;abc&#x27;,
  expected: &#x27;123&#x27;
};
const err = CommitMismatchError(testOptions);
assert.strictEqual(err.actual, testOptions.actual);
assert.strictEqual(err.expected, testOptions.expected);
assert.strictEqual(err.operator, &#x27;===&#x27;);
assert(
  err.message.indexOf(testOptions.actual) &#x3E;= 0,
  &#x27;constructs message with actual&#x27;
);
assert(
  err.message.indexOf(testOptions.expected) &#x3E;= 0,
  &#x27;constructs message with expected&#x27;
);</code></pre></dd>
        <dt>inherits from Error</dt>
        <dd><pre><code>const testOptions = {
  actual: &#x27;abc&#x27;,
  expected: &#x27;123&#x27;
};
const err = new CommitMismatchError(testOptions);
assert(err instanceof Error);</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>execFileOut</h1>
      <dl>
        <dt>returns a Promise with stdout</dt>
        <dd><pre><code>const testOut = &#x27;stdout content&#x27;;
const testArgs = [&#x27;-e&#x27;, makeScript(testOut)];
return execFileOut(process.execPath, testArgs)
  .then((stdout) =&#x3E; {
    assert.strictEqual(stdout, testOut);
  });</code></pre></dd>
        <dt>returns a Promise with stdout as Buffer</dt>
        <dd><pre><code>const testOut = &#x27;stdout content&#x27;;
const testArgs = [&#x27;-e&#x27;, makeScript(testOut)];
const options = {encoding: &#x27;buffer&#x27;};
return execFileOut(process.execPath, testArgs, options)
  .then((stdout) =&#x3E; {
    deepStrictEqual(stdout, Buffer.from(testOut));
  });</code></pre></dd>
        <dt>rejects Promise with Error for non-0 exit code</dt>
        <dd><pre><code>const testOut = &#x27;stdout content&#x27;;
const testCode = 2;
const testArgs = [&#x27;-e&#x27;, makeScript(testOut, null, testCode)];
return execFileOut(process.execPath, testArgs).then(
  neverCalled,
  (err) =&#x3E; {
    assert.strictEqual(
      err.cmd,
      [process.execPath].concat(testArgs).join(&#x27; &#x27;)
    );
    assert.strictEqual(err.code, testCode);
    assert.strictEqual(err.stderr, &#x27;&#x27;);
    assert.strictEqual(err.stdout, testOut);
  }
);</code></pre></dd>
        <dt>rejects Promise with Error for non-empty stderr</dt>
        <dd><pre><code>const testOut = &#x27;stdout content&#x27;;
const testErr = &#x27;stderr content&#x27;;
const testArgs = [&#x27;-e&#x27;, makeScript(testOut, testErr)];
return execFileOut(process.execPath, testArgs).then(
  neverCalled,
  (err) =&#x3E; {
    assert(err.message.indexOf(testErr) &#x3E;= 0, &#x27;stderr is in message&#x27;);
    assert.strictEqual(
      err.cmd,
      [process.execPath].concat(testArgs).join(&#x27; &#x27;)
    );
    assert.strictEqual(err.code, 0);
    assert.strictEqual(err.stderr, testErr);
    assert.strictEqual(err.stdout, testOut);
  }
);</code></pre></dd>
        <dt>rejects Promise with Error for non-empty stderr Buffer</dt>
        <dd><pre><code>const testOut = &#x27;stdout content&#x27;;
const testErr = &#x27;stderr content&#x27;;
const testArgs = [&#x27;-e&#x27;, makeScript(testOut, testErr)];
const options = {encoding: &#x27;buffer&#x27;};
return execFileOut(process.execPath, testArgs, options).then(
  neverCalled,
  (err) =&#x3E; {
    assert(err.message.indexOf(testErr) &#x3E;= 0, &#x27;stderr is in message&#x27;);
    assert.strictEqual(
      err.cmd,
      [process.execPath].concat(testArgs).join(&#x27; &#x27;)
    );
    assert.strictEqual(err.code, 0);
    deepStrictEqual(err.stderr, Buffer.from(testErr));
    deepStrictEqual(err.stdout, Buffer.from(testOut));
  }
);</code></pre></dd>
        <dt>does not reject stderr with only whitespace</dt>
        <dd><pre><code>const testOut = &#x27;stdout content&#x27;;
const testErr = &#x27;\n\t\t  \n&#x27;;
const testArgs = [&#x27;-e&#x27;, makeScript(testOut, testErr)];
return execFileOut(process.execPath, testArgs)
  .then((stdout) =&#x3E; {
    assert.strictEqual(stdout, testOut);
  });</code></pre></dd>
        <dt>closes stdin to prevent hanging</dt>
        <dd><pre><code>// Test will timeout if stdin is not closed
    execFileOut(process.execPath)</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>gitUtils</h1>
      <dl>
        <section class="suite">
          <h1>.getBranch</h1>
          <dl>
            <dt>resolves master on master</dt>
            <dd><pre><code>gitUtils.getBranch(options).then((branch) =&#x3E; {
        assert.strictEqual(branch, &#x27;master&#x27;);
      })</code></pre></dd>
            <dt>resolves branch1 on branch1</dt>
            <dd><pre><code>execFileOut(&#x27;git&#x27;, [&#x27;checkout&#x27;, &#x27;-q&#x27;, &#x27;branch1&#x27;], options)
        .then(() =&#x3E; gitUtils.getBranch(options))
        .then((branch) =&#x3E; {
          assert.strictEqual(branch, &#x27;branch1&#x27;);
        })</code></pre></dd>
            <dt>rejects with Error not on branch</dt>
            <dd><pre><code>execFileOut(&#x27;git&#x27;, [&#x27;checkout&#x27;, &#x27;-q&#x27;, &#x27;HEAD^&#x27;], options)
        .then(() =&#x3E; gitUtils.getBranch(options))
        .then(
          neverCalled,
          (err) =&#x3E; {
            assert.instanceOf(err, Error);
            assert.match(err.message, /branch/i);
          }
        )</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.getRemote</h1>
          <dl>
            <dt>resolves master to origin</dt>
            <dd><pre><code>gitUtils.getRemote(branch, options).then((result) =&#x3E; {
          assert.strictEqual(result, remote);
        })</code></pre></dd>
            <dt>resolves branch1 to remote1</dt>
            <dd><pre><code>gitUtils.getRemote(branch, options).then((result) =&#x3E; {
          assert.strictEqual(result, remote);
        })</code></pre></dd>
            <dt>resolves branch2 to remote2</dt>
            <dd><pre><code>gitUtils.getRemote(branch, options).then((result) =&#x3E; {
          assert.strictEqual(result, remote);
        })</code></pre></dd>
            <dt>resolves branchnourl to nourl</dt>
            <dd><pre><code>gitUtils.getRemote(branch, options).then((result) =&#x3E; {
          assert.strictEqual(result, remote);
        })</code></pre></dd>
            <dt>resolves branchnotslug to notslug</dt>
            <dd><pre><code>gitUtils.getRemote(branch, options).then((result) =&#x3E; {
          assert.strictEqual(result, remote);
        })</code></pre></dd>
            <dt>rejects branch without remote with Error</dt>
            <dd><pre><code>gitUtils.getRemote(&#x27;branchnoremote&#x27;, options).then(
        neverCalled,
        (err) =&#x3E; {
          assert.instanceOf(err, Error);
        }
      )</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.getRemoteUrl</h1>
          <dl>
            <dt>resolves notslug to foo</dt>
            <dd><pre><code>gitUtils.getRemoteUrl(remoteName, options)
          .then((resultUrl) =&#x3E; {
            assert.strictEqual(resultUrl, remoteUrl);
          })</code></pre></dd>
            <dt>resolves origin to https://github.com/owner/repo</dt>
            <dd><pre><code>gitUtils.getRemoteUrl(remoteName, options)
          .then((resultUrl) =&#x3E; {
            assert.strictEqual(resultUrl, remoteUrl);
          })</code></pre></dd>
            <dt>resolves remote1 to git@github.com:owner1/repo1.git</dt>
            <dd><pre><code>gitUtils.getRemoteUrl(remoteName, options)
          .then((resultUrl) =&#x3E; {
            assert.strictEqual(resultUrl, remoteUrl);
          })</code></pre></dd>
            <dt>resolves remote2 to https://github.com/owner2/repo2.git</dt>
            <dd><pre><code>gitUtils.getRemoteUrl(remoteName, options)
          .then((resultUrl) =&#x3E; {
            assert.strictEqual(resultUrl, remoteUrl);
          })</code></pre></dd>
            <dt>rejects invalid remote with Error</dt>
            <dd><pre><code>gitUtils.getRemoteUrl(&#x27;invalidremote&#x27;, options).then(
        neverCalled,
        (err) =&#x3E; {
          assert.instanceOf(err, Error);
        }
      )</code></pre></dd>
            <dt>uses ls-remote default for unspecified remote</dt>
            <dd><pre><code>gitUtils.getRemoteUrl(null, options)
        .then((resultUrl) =&#x3E; {
          assert.strictEqual(resultUrl, REMOTES.origin);
        })</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.gitUrlIsLocalNotSsh</h1>
          <dl>
            <dt>. is true</dt>
            <dd><pre><code>assert.strictEqual(
  gitUtils.gitUrlIsLocalNotSsh(testCase.url),
  testCase.result
);</code></pre></dd>
            <dt>/foo/bar is true</dt>
            <dd><pre><code>assert.strictEqual(
  gitUtils.gitUrlIsLocalNotSsh(testCase.url),
  testCase.result
);</code></pre></dd>
            <dt>http://example.com is false</dt>
            <dd><pre><code>assert.strictEqual(
  gitUtils.gitUrlIsLocalNotSsh(testCase.url),
  testCase.result
);</code></pre></dd>
            <dt>git://example.com is false</dt>
            <dd><pre><code>assert.strictEqual(
  gitUtils.gitUrlIsLocalNotSsh(testCase.url),
  testCase.result
);</code></pre></dd>
            <dt>git@example.com:foo is false</dt>
            <dd><pre><code>assert.strictEqual(
  gitUtils.gitUrlIsLocalNotSsh(testCase.url),
  testCase.result
);</code></pre></dd>
            <dt>file:///foo/bar is false</dt>
            <dd><pre><code>assert.strictEqual(
  gitUtils.gitUrlIsLocalNotSsh(testCase.url),
  testCase.result
);</code></pre></dd>
            <dt>/foo:bar is true</dt>
            <dd><pre><code>assert.strictEqual(
  gitUtils.gitUrlIsLocalNotSsh(testCase.url),
  testCase.result
);</code></pre></dd>
            <dt>foo:bar is false</dt>
            <dd><pre><code>assert.strictEqual(
  gitUtils.gitUrlIsLocalNotSsh(testCase.url),
  testCase.result
);</code></pre></dd>
            <dt>C:/foo is false on non-Windows</dt>
            <dd><pre><code>assert.strictEqual(
  gitUtils.gitUrlIsLocalNotSsh(drivePath),
  false
);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.parseGitUrl</h1>
          <dl>
            <dt>parses http: like url module</dt>
            <dd><pre><code>const testUrl = &#x27;http://user@example.com/foo/bar&#x27;;
deepStrictEqual(
  gitUtils.parseGitUrl(testUrl),
  assign(url.parse(testUrl), {helper: undefined})
);</code></pre></dd>
            <dt>parses git: like url module</dt>
            <dd><pre><code>const testUrl = &#x27;git://user@example.com/foo/bar&#x27;;
deepStrictEqual(
  gitUtils.parseGitUrl(testUrl),
  assign(url.parse(testUrl), {helper: undefined})
);</code></pre></dd>
            <dt>parses SCP-like URL like ssh: URL</dt>
            <dd><pre><code>const testUrl = &#x27;user@example.com:foo/bar.git&#x27;;
deepStrictEqual(
  gitUtils.parseGitUrl(testUrl),
  assign(
    url.parse(&#x27;ssh://user@example.com/foo/bar.git&#x27;),
    {helper: undefined}
  )
);</code></pre></dd>
            <dt>parses absolute path like file:// URL</dt>
            <dd><pre><code>const testPath = path.resolve(path.join(&#x27;foo&#x27;, &#x27;bar&#x27;));
deepStrictEqual(
  gitUtils.parseGitUrl(testPath),
  assign(url.parse(fileUrl(testPath)), {helper: undefined})
);</code></pre></dd>
            <dt>parses relative path like file:// URL</dt>
            <dd><pre><code>const testPath = path.join(&#x27;foo&#x27;, &#x27;bar&#x27;);
deepStrictEqual(
  gitUtils.parseGitUrl(testPath),
  assign(url.parse(fileUrl(testPath)), {helper: undefined})
);</code></pre></dd>
            <dt>parses Windows path like URL on non-Windows</dt>
            <dd><pre><code>const testPath = &#x27;C:\\foo\\bar&#x27;;
deepStrictEqual(
  gitUtils.parseGitUrl(testPath),
  assign(url.parse(testPath), {helper: undefined})
);</code></pre></dd>
            <dt>adds helper property for transport helper</dt>
            <dd><pre><code>const testUrl = &#x27;myhelper::user@example.com:foo/bar.git&#x27;;
deepStrictEqual(
  gitUtils.parseGitUrl(testUrl),
  assign(
    url.parse(&#x27;ssh://user@example.com/foo/bar.git&#x27;),
    {helper: &#x27;myhelper&#x27;}
  )
);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.resolveCommit</h1>
          <dl>
            <dt>can resolve the hash of HEAD</dt>
            <dd><pre><code>gitUtils.resolveCommit(&#x27;HEAD&#x27;, options).then((hash) =&#x3E; {
        assert.match(hash, /^[a-fA-F0-9]{40}$/);
        headHash = hash;
      })</code></pre></dd>
            <dt>can resolve a hash to itself</dt>
            <dd><pre><code>gitUtils.resolveCommit(headHash, options).then((hash) =&#x3E; {
        assert.strictEqual(hash, headHash);
      })</code></pre></dd>
            <dt>can resolve branch name to commit hash</dt>
            <dd><pre><code>const branchName = Object.keys(BRANCH_REMOTES)[0];
return gitUtils.resolveCommit(branchName, options).then((hash) =&#x3E; {
  assert.match(hash, /^[a-fA-F0-9]{40}$/);
});</code></pre></dd>
            <dt>can resolve tag name to commit hash</dt>
            <dd><pre><code>gitUtils.resolveCommit(TAGS[0], options).then((hash) =&#x3E; {
        assert.match(hash, /^[a-fA-F0-9]{40}$/);
      })</code></pre></dd>
            <dt>rejects with Error for unresolvable name</dt>
            <dd><pre><code>gitUtils.resolveCommit(&#x27;notabranch&#x27;, options).then(
        neverCalled,
        (err) =&#x3E; {
          assert(err instanceof Error);
        }
      )</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
  </div><!-- .container -->

  <script type="text/javascript" src="https://cdn.jsdelivr.net/jquery/2.2.1/jquery.min.js"></script>
  <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/highlight.js/9.1.0/highlight.min.js"></script>
  <script type="text/javascript">//<![CDATA[
'use strict';
// Adjust the nested heading level to match depth
$('section section h1').each(function() {
  var $this = $(this);
  var depth = Math.min($this.parents('section').length, 6);
  // http://stackoverflow.com/a/30059450/503410
  $this.wrapInner(document.createElement('h' + depth)).children().unwrap();
});

// Make the tests collapsible
var testNum = 0;
$('dt + dd')
  .addClass('collapse')
  .attr('role', 'tabpanel')
  .attr('aria-expanded', 'false')
  .each(function() {
    var $this = $(this);
    var $dt = $this.prev();

    ++testNum;
    var id = 'test' + testNum;
    var idDt = id + '-title';
    var idDd = id + '-desc';

    $dt.attr('id', idDt);
    $this.attr('id', idDd);

    $dt.wrapInner('<a role="button" data-toggle="collapse" href="#' + idDd +
        '" aria-expanded="false" aria-controls="' + idDd + '"></a>')
      .children()
      .collapse();
  });

// Enable syntax highlighting for the code (which is all JavaScript)
hljs.configure({languages: ['javascript']});
hljs.initHighlighting();
//]]></script>
</body>
</html>
