<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Specifications in Mocha</title>
  <meta name="generator" content="Mocha &lt;https://mochajs.org/&gt;" />
  <meta name="license" content="MIT" />
  <meta name="copyright" content="&#169; 2016 Kevin Locke &lt;kevin@kevinlocke.name&gt;" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css" integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r" crossorigin="anonymous" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/highlight.js/9.1.0/styles/github.min.css" />
  <style type="text/css">
section section {
  margin-left: 1em;
}
section section section section {
  margin-left: 0;
}
  </style>
</head>
<body>
  <div class="container">
    <section class="suite">
      <h1>appveyorStatus</h1>
      <dl>
        <section class="suite">
          <h1>.getLastBuild</h1>
          <dl>
            <dt>queries last build for options.project</dt>
            <dd><pre><code>const testProject = &#x27;foo/bar&#x27;;
const testStatus = &#x27;success&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  .get(&#x60;/api/projects/${testProject}&#x60;)
  .query(true)
  .reply(200, apiResponses.getProjectBuild({status: testStatus}));
options.project = testProject;
return appveyorStatus.getLastBuild(options)
  .then((projectBuild) =&#x3E; {
    assert.strictEqual(projectBuildToStatus(projectBuild), testStatus);
    ne.done();
  });</code></pre></dd>
            <dt>queries last build for project with named branch</dt>
            <dd><pre><code>const testBranch = &#x27;testb&#x27;;
const testProject = &#x27;foo/bar&#x27;;
const testStatus = &#x27;success&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  .get(&#x60;/api/projects/${testProject}/branch/${testBranch}&#x60;)
  .query(true)
  .reply(200, apiResponses.getProjectBuild({status: testStatus}));
options.branch = testBranch;
options.project = testProject;
return appveyorStatus.getLastBuild(options)
  .then((projectBuild) =&#x3E; {
    assert.strictEqual(projectBuildToStatus(projectBuild), testStatus);
    ne.done();
  });</code></pre></dd>
            <dt>queries last build for named branch by remote</dt>
            <dd><pre><code>const testBranch = &#x27;testb&#x27;;
const testRemote = &#x27;testr&#x27;;
const testRemoteUrl = &#x27;git://foo.bar/baz&#x27;;
const testStatus = &#x27;success&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;)
  .once().withArgs(testBranch, matchOptionsCwd).resolves(testRemote);
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;)
  .once().withArgs(testRemote, matchOptionsCwd).resolves(testRemoteUrl);
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  .get(&#x27;/api/projects&#x27;)
  .query(true)
  .reply(200, [
    apiResponses.getProject({
      branch: testBranch,
      repositoryType: &#x27;git&#x27;,
      repositoryName: testRemoteUrl,
      status: testStatus
    })
  ]);
options.branch = testBranch;
return appveyorStatus.getLastBuild(options)
  .then((projectBuild) =&#x3E; {
    assert.strictEqual(projectBuildToStatus(projectBuild), testStatus);
    ne.done();
  });</code></pre></dd>
            <dt>queries non-last build for named branch by remote</dt>
            <dd><pre><code>const testBranch = &#x27;testb&#x27;;
const testProject = [&#x27;foo&#x27;, &#x27;bar&#x27;];
const testRemote = &#x27;testr&#x27;;
const testRemoteUrl = &#x27;git://foo.bar/baz&#x27;;
const testStatus = &#x27;success&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;)
  .once().withArgs(testBranch, matchOptionsCwd).resolves(testRemote);
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;)
  .once().withArgs(testRemote, matchOptionsCwd).resolves(testRemoteUrl);
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  .get(&#x27;/api/projects&#x27;)
  .query(true)
  .reply(200, [
    apiResponses.getProject({
      accountName: testProject[0],
      branch: &#x60;${testBranch}5&#x60;,
      repositoryType: &#x27;git&#x27;,
      repositoryName: testRemoteUrl,
      slug: testProject[1],
      status: testStatus
    })
  ])
  .get(&#x60;/api/projects/${testProject.join(&#x27;/&#x27;)}/branch/${testBranch}&#x60;)
  .query(true)
  .reply(200, apiResponses.getProjectBuild({
    branch: testBranch,
    repositoryType: &#x27;git&#x27;,
    repositoryName: testRemoteUrl,
    status: testStatus
  }));
options.branch = testBranch;
return appveyorStatus.getLastBuild(options)
  .then((projectBuild) =&#x3E; {
    assert.strictEqual(projectBuildToStatus(projectBuild), testStatus);
    ne.done();
  });</code></pre></dd>
            <dt>uses commit hash without resolving</dt>
            <dd><pre><code>const testCommit = &#x27;adc83b19e793491b1c6ea0fd8b46cd9f32e592a1&#x27;;
const testProject = &#x27;foo/bar&#x27;;
const testStatus = &#x27;success&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  .get(&#x60;/api/projects/${testProject}&#x60;)
  .query(true)
  .reply(200, apiResponses.getProjectBuild({
    commitId: testCommit,
    status: testStatus
  }));
options.commit = testCommit;
options.project = testProject;
return appveyorStatus.getLastBuild(options)
  .then((projectBuild) =&#x3E; {
    assert.strictEqual(projectBuildToStatus(projectBuild), testStatus);
    ne.done();
  });</code></pre></dd>
            <dt>rejects with CommitMismatchError if commit does not match</dt>
            <dd><pre><code>const testCommit = &#x27;testtag&#x27;;
const testProject = &#x27;foo/bar&#x27;;
const testStatus = &#x27;success&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;)
  .once().withArgs(testCommit, matchOptionsCwd).resolves(&#x27;abcde&#x27;);
const ne = nock(apiUrl)
  .get(&#x60;/api/projects/${testProject}&#x60;)
  .query(true)
  .reply(200, apiResponses.getProjectBuild({
    commitId: &#x27;12345&#x27;,
    status: testStatus
  }));
options.commit = testCommit;
options.project = testProject;
return appveyorStatus.getLastBuild(options).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;CommitMismatchError&#x27;);
    ne.done();
  }
);</code></pre></dd>
            <dt>returns queued status as-is without wait</dt>
            <dd><pre><code>const testProject = &#x27;foo/bar&#x27;;
const testStatus = &#x27;queued&#x27;;
const ne = nock(apiUrl)
  .get(&#x60;/api/projects/${testProject}&#x60;)
  .query(true)
  .reply(200, apiResponses.getProjectBuild({status: testStatus}));
options.project = testProject;
return appveyorStatus.getLastBuild(options)
  .then((projectBuild) =&#x3E; {
    assert.strictEqual(projectBuildToStatus(projectBuild), testStatus);
    ne.done();
  });</code></pre></dd>
            <dt>queries repo in cwd by default</dt>
            <dd><pre><code>const testBranch = &#x27;testb&#x27;;
const testRemote = &#x27;testr&#x27;;
const testRemoteUrl = &#x27;git://foo.bar/baz&#x27;;
const testStatus = &#x27;success&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;)
  .once().withArgs(matchOptionsCwd).resolves(testBranch);
gitUtilsMock.expects(&#x27;getRemote&#x27;)
  .once().withArgs(testBranch, matchOptionsCwd).resolves(testRemote);
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;)
  .once().withArgs(testRemote, matchOptionsCwd).resolves(testRemoteUrl);
const ne = nock(apiUrl)
  .get(&#x27;/api/projects&#x27;)
  .reply(200, [
    apiResponses.getProject({
      repositoryType: &#x27;git&#x27;,
      repositoryName: testRemoteUrl,
      status: testStatus
    })
  ]);
return appveyorStatus.getLastBuild(options)
  .then((projectBuild) =&#x3E; {
    assert.strictEqual(projectBuildToStatus(projectBuild), testStatus);
    ne.done();
  });</code></pre></dd>
            <dt>resolves branch, commit, and remote URL in local repo</dt>
            <dd><pre><code>const testBranch = &#x27;testb&#x27;;
const testCommit = &#x27;testtag&#x27;;
const testCommitHash = &#x27;4b482f89ef23e06ad6a9c01adaece30943bf434c&#x27;;
const testRemote = &#x27;testr&#x27;;
const testRemoteUrl = &#x27;git://foo.bar/baz&#x27;;
const testRepo = &#x27;foo/bar&#x27;;
const testStatus = &#x27;success&#x27;;
const matchRepoCwd = match({cwd: testRepo});
gitUtilsMock.expects(&#x27;getBranch&#x27;)
  .once().withArgs(matchRepoCwd).resolves(testBranch);
gitUtilsMock.expects(&#x27;getRemote&#x27;)
  .once().withArgs(testBranch, matchRepoCwd).resolves(testRemote);
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;)
  .once().withArgs(testRemote, matchRepoCwd).resolves(testRemoteUrl);
gitUtilsMock.expects(&#x27;resolveCommit&#x27;)
  .once().withArgs(testCommit, matchRepoCwd).resolves(testCommitHash);
const ne = nock(apiUrl)
  .get(&#x27;/api/projects&#x27;)
  .reply(200, [
    apiResponses.getProject({
      branch: testBranch,
      commitId: testCommitHash,
      repositoryType: &#x27;git&#x27;,
      repositoryName: testRemoteUrl,
      status: testStatus
    })
  ]);
options.branch = true;
options.commit = testCommit;
options.repo = testRepo;
return appveyorStatus.getLastBuild(options)
  .then((projectBuild) =&#x3E; {
    assert.strictEqual(projectBuildToStatus(projectBuild), testStatus);
    ne.done();
  });</code></pre></dd>
            <dt>falls back to origin if not on a branch</dt>
            <dd><pre><code>const testRemoteUrl = &#x27;git://foo.bar/baz&#x27;;
const testStatus = &#x27;success&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;)
  .once().withArgs(matchOptionsCwd).rejects(new Error());
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;)
  .once().withArgs(&#x27;origin&#x27;, matchOptionsCwd).resolves(testRemoteUrl);
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  .get(&#x27;/api/projects&#x27;)
  .reply(200, [
    apiResponses.getProject({
      repositoryType: &#x27;git&#x27;,
      repositoryName: testRemoteUrl,
      status: testStatus
    })
  ]);
return appveyorStatus.getLastBuild(options)
  .then((projectBuild) =&#x3E; {
    assert.strictEqual(options.err.read(), null);
    assert.strictEqual(projectBuildToStatus(projectBuild), testStatus);
    ne.done();
  });</code></pre></dd>
            <dt>falls back to origin if branch has no remote</dt>
            <dd><pre><code>const testBranch = &#x27;testb&#x27;;
const testRemoteUrl = &#x27;git://foo.bar/baz&#x27;;
const testStatus = &#x27;success&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;)
  .once().withArgs(matchOptionsCwd).resolves(testBranch);
gitUtilsMock.expects(&#x27;getRemote&#x27;)
  .once().withArgs(testBranch, matchOptionsCwd).rejects(new Error());
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;)
  .once().withArgs(&#x27;origin&#x27;, matchOptionsCwd).resolves(testRemoteUrl);
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  .get(&#x27;/api/projects&#x27;)
  .reply(200, [
    apiResponses.getProject({
      repositoryType: &#x27;git&#x27;,
      repositoryName: testRemoteUrl,
      status: testStatus
    })
  ]);
options.verbosity = 1;
return appveyorStatus.getLastBuild(options)
  .then((projectBuild) =&#x3E; {
    const errStr = String(options.err.read());
    assert.match(errStr, /\bremote\b/i);
    assert.match(errStr, /\borigin\b/i);
    assert.strictEqual(projectBuildToStatus(projectBuild), testStatus);
    ne.done();
  });</code></pre></dd>
            <dt>rejects with Error if no project matches repo</dt>
            <dd><pre><code>const testRepo = &#x27;git://foo.bar/baz&#x27;;
const testStatus = &#x27;success&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  .get(&#x27;/api/projects&#x27;)
  .query(true)
  .reply(200, [
    apiResponses.getProject({
      repositoryType: &#x27;git&#x27;,
      repositoryName: &#x60;${testRepo}/quux&#x60;,
      status: testStatus
    })
  ]);
options.repo = testRepo;
return appveyorStatus.getLastBuild(options).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.instanceOf(err, Error);
    assert.include(err.message, testRepo);
    ne.done();
  }
);</code></pre></dd>
            <dt>AmbiguousProjectError if multiple projects match repo</dt>
            <dd><pre><code>const testProject1 = [&#x27;myacct&#x27;, &#x27;proj1&#x27;];
const testProject2 = [&#x27;youracct&#x27;, &#x27;proj2&#x27;];
const testRepo = &#x27;git://foo.bar/baz&#x27;;
const testStatus = &#x27;success&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  .get(&#x27;/api/projects&#x27;)
  .query(true)
  .reply(200, [
    apiResponses.getProject({
      accountName: testProject1[0],
      repositoryType: &#x27;git&#x27;,
      repositoryName: testRepo,
      slug: testProject1[1],
      status: testStatus
    }),
    apiResponses.getProject({
      accountName: testProject2[0],
      repositoryType: &#x27;git&#x27;,
      repositoryName: testRepo,
      slug: testProject2[1],
      status: testStatus
    })
  ]);
options.repo = testRepo;
return appveyorStatus.getLastBuild(options).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.instanceOf(err, AmbiguousProjectError);
    assert.deepEqual(
      err.projects,
      [testProject1.join(&#x27;/&#x27;), testProject2.join(&#x27;/&#x27;)]
    );
    ne.done();
  }
);</code></pre></dd>
            <dt>rejects with Error for non-200 responses</dt>
            <dd><pre><code>const testErrMsg = &#x27;bad dead bodies&#x27;;
const testProject = &#x27;foo/bar&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  .get(&#x60;/api/projects/${testProject}&#x60;)
  .query(true)
  .reply(400, {message: testErrMsg});
options.project = testProject;
return appveyorStatus.getLastBuild(options).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.match(err.message, /400|Bad Request/i);
    assert.include(err.message, testErrMsg);
    assert.strictEqual(err.status, 400);
    ne.done();
  }
);</code></pre></dd>
            <dt>rejects with Error for non-JSON responses</dt>
            <dd><pre><code>const testProject = &#x27;foo/bar&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  .get(&#x60;/api/projects/${testProject}&#x60;)
  .query(true)
  .reply(200, &#x27;invalid&#x27;, {&#x27;Content-Type&#x27;: &#x27;text/plain&#x27;});
options.project = testProject;
return appveyorStatus.getLastBuild(options).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.include(err.message, &#x27;JSON&#x27;);
    ne.done();
  }
);</code></pre></dd>
            <dt>rejects with Error for request error</dt>
            <dd><pre><code>const testErrMsg = &#x27;something bad happened&#x27;;
const testProject = &#x27;foo/bar&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  .get(&#x60;/api/projects/${testProject}&#x60;)
  .query(true)
  .replyWithError(testErrMsg);
options.project = testProject;
return appveyorStatus.getLastBuild(options).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.include(err.message, testErrMsg);
    ne.done();
  }
);</code></pre></dd>
            <dt>passes options.token as bearer token</dt>
            <dd><pre><code>const testRepo = &#x27;git://foo.bar/baz&#x27;;
const testStatus = &#x27;success&#x27;;
const testToken = &#x27;testtoken&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  // IMPORTANT: Must be path which requires auth
  .get(&#x27;/api/projects&#x27;)
  .query(true)
  .reply(200, function(uri, requestBody) {
    assert.deepEqual(
      this.req.headers.authorization,
      [&#x60;Bearer ${testToken}&#x60;]
    );
    return [
      apiResponses.getProject({
        repositoryType: &#x27;git&#x27;,
        repositoryName: testRepo,
        status: testStatus
      })
    ];
  });
options.repo = testRepo;
options.token = testToken;
return appveyorStatus.getLastBuild(options)
  .then((projectBuild) =&#x3E; {
    assert.strictEqual(projectBuildToStatus(projectBuild), testStatus);
    ne.done();
  });</code></pre></dd>
            <dt>ignores options.token when appveyorClient is given</dt>
            <dd><pre><code>const testRepo = &#x27;git://foo.bar/baz&#x27;;
const testStatus = &#x27;success&#x27;;
const testToken1 = &#x27;testtoken1&#x27;;
const testToken2 = &#x27;testtoken2&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  // IMPORTANT: Must be path which requires auth
  .get(&#x27;/api/projects&#x27;)
  .query(true)
  .reply(200, function(uri, requestBody) {
    assert.deepEqual(
      this.req.headers.authorization,
      [&#x60;Bearer ${testToken2}&#x60;]
    );
    return [
      apiResponses.getProject({
        repositoryType: &#x27;git&#x27;,
        repositoryName: testRepo,
        status: testStatus
      })
    ];
  });
options.appveyorClient = new SwaggerClient({
  authorizations: {
    apiToken: &#x60;Bearer ${testToken2}&#x60;
  },
  spec: appveyorSwagger
});
options.repo = testRepo;
options.token = testToken1;
return appveyorStatus.getLastBuild(options)
  .then((projectBuild) =&#x3E; {
    assert.strictEqual(projectBuildToStatus(projectBuild), testStatus);
    ne.done();
  });</code></pre></dd>
            <dt>rejects with Error for statusBadgeId</dt>
            <dd><pre><code>gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
options.statusBadgeId = &#x27;abcde&#x27;;
return appveyorStatus.getLastBuild(options).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.match(err.message, /required|supported/i);
  }
);</code></pre></dd>
            <dt>rejects with Error for webhookId</dt>
            <dd><pre><code>gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
options.webhookId = &#x27;abcde&#x27;;
return appveyorStatus.getLastBuild(options).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.match(err.message, /required|supported/i);
  }
);</code></pre></dd>
            <section class="suite">
              <h1>with wait</h1>
              <dl>
                <dt>true retries queued status</dt>
                <dd><pre><code>const testProject = &#x27;foo/bar&#x27;;
const testStatus = &#x27;success&#x27;;
const expectQueued = nock(apiUrl)
  .get(&#x60;/api/projects/${testProject}&#x60;)
  .query(true)
  .reply(200, apiResponses.getProjectBuild({status: &#x27;queued&#x27;}));
const expectSuccess = nock(apiUrl)
  .get(&#x60;/api/projects/${testProject}&#x60;)
  .query(true)
  .reply(200, apiResponses.getProjectBuild({status: testStatus}));
let retriesDone = false;
afterFirstRequest(() =&#x3E; {
  assert(expectQueued.isDone(), &#x27;First call is made immediately.&#x27;);
  assert(!expectSuccess.isDone(), &#x27;Retry is not done immediately.&#x27;);
  clock.tick(900);
  assert(!expectSuccess.isDone(), &#x27;Retry is not done less than 1 sec.&#x27;);
  clock.tick(60000);
  assert(expectSuccess.isDone(), &#x27;Retry is done less than 1 minute.&#x27;);
  retriesDone = true;
});
options.project = testProject;
options.wait = true;
return appveyorStatus.getLastBuild(options)
  .then((projectBuild) =&#x3E; {
    assert.strictEqual(projectBuildToStatus(projectBuild), testStatus);
    assert(retriesDone, &#x27;Retries completed&#x27;);
    assert.strictEqual(
      options.err.read(),
      null,
      &#x27;does not print wait messages by default&#x27;
    );
  });</code></pre></dd>
                <dt>true retries running status from project</dt>
                <dd><pre><code>const testProjectParts = [&#x27;foo&#x27;, &#x27;bar&#x27;];
const testRepoUrl = &#x27;git://foo.bar/baz&#x27;;
const testStatus = &#x27;success&#x27;;
const expectQueued = nock(apiUrl)
  .get(&#x27;/api/projects&#x27;)
  .query(true)
  .reply(200, [
    apiResponses.getProject({
      accountName: testProjectParts[0],
      repositoryType: &#x27;git&#x27;,
      repositoryName: testRepoUrl,
      slug: testProjectParts[1],
      status: &#x27;running&#x27;
    })
  ]);
const expectSuccess = nock(apiUrl)
  .get(&#x60;/api/projects/${testProjectParts.join(&#x27;/&#x27;)}&#x60;)
  .query(true)
  .reply(200, apiResponses.getProjectBuild({status: testStatus}));
let retriesDone = false;
afterFirstRequest(() =&#x3E; {
  assert(expectQueued.isDone(), &#x27;First call is made immediately.&#x27;);
  assert(!expectSuccess.isDone(), &#x27;Retry is not done immediately.&#x27;);
  clock.tick(900);
  assert(!expectSuccess.isDone(), &#x27;Retry is not done less than 1 sec.&#x27;);
  clock.tick(60000);
  assert(expectSuccess.isDone(), &#x27;Retry is done less than 1 minute.&#x27;);
  retriesDone = true;
});
options.repo = testRepoUrl;
options.wait = true;
options.verbosity = 1;
return appveyorStatus.getLastBuild(options)
  .then((projectBuild) =&#x3E; {
    assert.strictEqual(projectBuildToStatus(projectBuild), testStatus);
    assert(retriesDone, &#x27;Retries completed&#x27;);
    assert.match(
      String(options.err.read()),
      /\bwait/i,
      &#x27;prints wait message when verbose&#x27;
    );
  });</code></pre></dd>
                <dt>is stopped on error</dt>
                <dd><pre><code>const testErrMsg = &#x27;something bad&#x27;;
const testProject = &#x27;foo/bar&#x27;;
const expectQueued = nock(apiUrl)
  .get(&#x60;/api/projects/${testProject}&#x60;)
  .query(true)
  .reply(200, apiResponses.getProjectBuild({status: &#x27;queued&#x27;}));
const expectSuccess = nock(apiUrl)
  .get(&#x60;/api/projects/${testProject}&#x60;)
  .query(true)
  .replyWithError(testErrMsg);
let retriesDone = false;
afterFirstRequest(() =&#x3E; {
  assert(expectQueued.isDone(), &#x27;First call is made immediately.&#x27;);
  assert(!expectSuccess.isDone(), &#x27;Retry is not done immediately.&#x27;);
  clock.tick(900);
  assert(!expectSuccess.isDone(), &#x27;Retry is not done less than 1 sec.&#x27;);
  clock.tick(60000);
  assert(expectSuccess.isDone(), &#x27;Retry is done less than 1 minute.&#x27;);
  retriesDone = true;
});
options.project = testProject;
options.wait = true;
return appveyorStatus.getLastBuild(options).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.include(err.message, testErrMsg);
    assert(retriesDone, &#x27;Retries completed&#x27;);
  }
);</code></pre></dd>
                <dt>returns queued status if wait elapses</dt>
                <dd><pre><code>const testProject = &#x27;foo/bar&#x27;;
const expectQueued1 = nock(apiUrl)
  .get(&#x60;/api/projects/${testProject}&#x60;)
  .query(true)
  .reply(200, apiResponses.getProjectBuild({status: &#x27;queued&#x27;}));
const expectQueued2 = nock(apiUrl)
  .get(&#x60;/api/projects/${testProject}&#x60;)
  .query(true)
  .reply(200, apiResponses.getProjectBuild({status: &#x27;queued&#x27;}));
// This test does not specify specifics of exponential backoff
nock(apiUrl)
  .persist()
  .get(&#x60;/api/projects/${testProject}&#x60;)
  .query(true)
  .reply(200, apiResponses.getProjectBuild({status: &#x27;queued&#x27;}));
let retriesDone = false;
afterFirstRequest(() =&#x3E; {
  assert(expectQueued1.isDone(), &#x27;First call is made immediately.&#x27;);
  assert(!expectQueued2.isDone(), &#x27;Retry is not done immediately.&#x27;);
  clock.tick(900);
  assert(!expectQueued2.isDone(), &#x27;Retry is not done less than 1 sec.&#x27;);
  clock.tick(60000);
  assert(expectQueued2.isDone(), &#x27;Retry is done less than 1 minute.&#x27;);
  retriesDone = true;
});
options.project = testProject;
options.wait = 8000;
return appveyorStatus.getLastBuild(options)
  .then((projectBuild) =&#x3E; {
    assert.strictEqual(projectBuildToStatus(projectBuild), &#x27;queued&#x27;);
    assert(retriesDone, &#x27;Retries completed&#x27;);
  });</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>.getStatusBadge</h1>
          <dl>
            <dt>queries badge by repo URL</dt>
            <dd><pre><code>const testBadgeUrlPath = &#x27;gitHub/foo/bar&#x27;;
const testRepoUrl = &#x27;git@github.com:foo/bar.git&#x27;;
const testStatus = &#x27;success&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  .get(&#x60;/api/projects/status/${testBadgeUrlPath}&#x60;)
  .query(true)
  .reply(
    200,
    apiResponses.getStatusBadge(testStatus),
    {&#x27;Content-Type&#x27;: &#x27;image/svg+xml&#x27;}
  );
options.repo = testRepoUrl;
return appveyorStatus.getStatusBadge(options)
  .then((badge) =&#x3E; {
    assert.strictEqual(badgeToStatus(badge), testStatus);
    ne.done();
  });</code></pre></dd>
            <dt>queries badge by repo URL and branch</dt>
            <dd><pre><code>const testBadgeUrlPath = &#x27;gitHub/foo/bar&#x27;;
const testBranch = &#x27;testb&#x27;;
const testRepoUrl = &#x27;git@github.com:foo/bar.git&#x27;;
const testStatus = &#x27;success&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  .get(&#x60;/api/projects/status/${testBadgeUrlPath}&#x60;)
  .query((query) =&#x3E; query.branch === testBranch &#x26;&#x26; query.svg === &#x27;true&#x27;)
  .reply(
    200,
    apiResponses.getStatusBadge(testStatus),
    {&#x27;Content-Type&#x27;: &#x27;image/svg+xml&#x27;}
  );
options.branch = testBranch;
options.repo = testRepoUrl;
return appveyorStatus.getStatusBadge(options)
  .then((badge) =&#x3E; {
    assert.strictEqual(badgeToStatus(badge), testStatus);
    ne.done();
  });</code></pre></dd>
            <dt>queries badge by statusBadgeId</dt>
            <dd><pre><code>const testStatusBadgeId = &#x27;abcde&#x27;;
const testStatus = &#x27;success&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  .get(&#x60;/api/projects/status/${testStatusBadgeId}&#x60;)
  .query(true)
  .reply(
    200,
    apiResponses.getStatusBadge(testStatus),
    {&#x27;Content-Type&#x27;: &#x27;image/svg+xml&#x27;}
  );
options.statusBadgeId = testStatusBadgeId;
return appveyorStatus.getStatusBadge(options)
  .then((badge) =&#x3E; {
    assert.strictEqual(badgeToStatus(badge), testStatus);
    ne.done();
  });</code></pre></dd>
            <dt>queries badge by webhookId</dt>
            <dd><pre><code>const testWebhookId = &#x27;abcde&#x27;;
const testStatus = &#x27;success&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  .get(&#x60;/api/projects/status/${testWebhookId}&#x60;)
  .query(true)
  .reply(
    200,
    apiResponses.getStatusBadge(testStatus),
    {&#x27;Content-Type&#x27;: &#x27;image/svg+xml&#x27;}
  );
options.webhookId = testWebhookId;
return appveyorStatus.getStatusBadge(options)
  .then((badge) =&#x3E; {
    assert.strictEqual(badgeToStatus(badge), testStatus);
    ne.done();
  });</code></pre></dd>
            <dt>queries badge by statusBadgeId and branch</dt>
            <dd><pre><code>const testBranch = &#x27;testb&#x27;;
const testStatusBadgeId = &#x27;abcde&#x27;;
const testStatus = &#x27;success&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  .get(&#x60;/api/projects/status/${testStatusBadgeId}/branch/${testBranch}&#x60;)
  .query(true)
  .reply(
    200,
    apiResponses.getStatusBadge(testStatus),
    {&#x27;Content-Type&#x27;: &#x27;image/svg+xml&#x27;}
  );
options.branch = testBranch;
options.statusBadgeId = testStatusBadgeId;
return appveyorStatus.getStatusBadge(options)
  .then((badge) =&#x3E; {
    assert.strictEqual(badgeToStatus(badge), testStatus);
    ne.done();
  });</code></pre></dd>
            <dt>queries badge by webhookId and branch</dt>
            <dd><pre><code>const testBranch = &#x27;testb&#x27;;
const testWebhookId = &#x27;abcde&#x27;;
const testStatus = &#x27;success&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  .get(&#x60;/api/projects/status/${testWebhookId}/branch/${testBranch}&#x60;)
  .query(true)
  .reply(
    200,
    apiResponses.getStatusBadge(testStatus),
    {&#x27;Content-Type&#x27;: &#x27;image/svg+xml&#x27;}
  );
options.branch = testBranch;
options.webhookId = testWebhookId;
return appveyorStatus.getStatusBadge(options)
  .then((badge) =&#x3E; {
    assert.strictEqual(badgeToStatus(badge), testStatus);
    ne.done();
  });</code></pre></dd>
            <dt>rejects with Error for non-200 response</dt>
            <dd><pre><code>const testWebhookId = &#x27;abcde&#x27;;
const testStatus = &#x27;success&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  .get(&#x60;/api/projects/status/${testWebhookId}&#x60;)
  .query(true)
  .reply(
    400,
    apiResponses.getStatusBadge(testStatus),
    {&#x27;Content-Type&#x27;: &#x27;image/svg+xml&#x27;}
  );
options.statusBadgeId = testWebhookId;
return appveyorStatus.getStatusBadge(options).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.match(err.message, /400|Bad Request/i);
    assert.strictEqual(err.status, 400);
    ne.done();
  }
);</code></pre></dd>
            <dt>rejects with Error for non-SVG response</dt>
            <dd><pre><code>const testWebhookId = &#x27;abcde&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  .get(&#x60;/api/projects/status/${testWebhookId}&#x60;)
  .query(true)
  .reply(200, &#x27;invalid&#x27;, {&#x27;Content-Type&#x27;: &#x27;text/plain&#x27;});
options.statusBadgeId = testWebhookId;
return appveyorStatus.getStatusBadge(options).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.match(err.message, /svg/i);
    ne.done();
  }
);</code></pre></dd>
            <dt>rejects with Error for response without Content-Type</dt>
            <dd><pre><code>const testStatusBadgeId = &#x27;abcde&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  .get(&#x60;/api/projects/status/${testStatusBadgeId}&#x60;)
  .query(true)
  .reply(200, &#x27;invalid&#x27;, {&#x27;Content-Type&#x27;: undefined});
options.statusBadgeId = testStatusBadgeId;
return appveyorStatus.getStatusBadge(options).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.match(err.message, /svg/i);
    ne.done();
  }
);</code></pre></dd>
            <dt>rejects with Error for options.project</dt>
            <dd><pre><code>gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
options.project = &#x27;foo/bar&#x27;;
return appveyorStatus.getStatusBadge(options).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.match(err.message, /required|supported/i);
  }
);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.getStatus</h1>
          <dl>
            <dt>returns status from last build for project</dt>
            <dd><pre><code>const testProject = &#x27;foo/bar&#x27;;
const testStatus = &#x27;success&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  .get(&#x60;/api/projects/${testProject}&#x60;)
  .reply(200, apiResponses.getProjectBuild({status: testStatus}));
options.project = testProject;
return appveyorStatus.getStatus(options)
  .then((status) =&#x3E; {
    assert.strictEqual(status, testStatus);
    ne.done();
  });</code></pre></dd>
            <dt>returns status from badge for GitHub repo</dt>
            <dd><pre><code>const testProject = &#x27;foo/bar&#x27;;
const testRepo = &#x60;https://github.com/${testProject}.git&#x60;;
const testStatus = &#x27;success&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;).never();
gitUtilsMock.expects(&#x27;getRemote&#x27;).never();
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;).never();
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  .get(&#x60;/api/projects/status/gitHub/${testProject}&#x60;)
  .query(true)
  .reply(
    200,
    apiResponses.getStatusBadge(testStatus),
    {&#x27;Content-Type&#x27;: &#x27;image/svg+xml&#x27;}
  );
options.repo = testRepo;
return appveyorStatus.getStatus(options)
  .then((status) =&#x3E; {
    assert.strictEqual(status, testStatus);
    ne.done();
  });</code></pre></dd>
            <dt>can be called with callback without options</dt>
            <dd><pre><code>const testBranch = &#x27;testb&#x27;;
const testProject = &#x27;foo/bar&#x27;;
const testRemote = &#x27;testr&#x27;;
const testRemoteUrl = &#x60;https://github.com/${testProject}.git&#x60;;
const testStatus = &#x27;success&#x27;;
gitUtilsMock.expects(&#x27;getBranch&#x27;)
  .once().withArgs(matchOptionsCwd).resolves(testBranch);
gitUtilsMock.expects(&#x27;getRemote&#x27;)
  .once().withArgs(testBranch, matchOptionsCwd).resolves(testRemote);
gitUtilsMock.expects(&#x27;getRemoteUrl&#x27;)
  .once().withArgs(testRemote, matchOptionsCwd).resolves(testRemoteUrl);
gitUtilsMock.expects(&#x27;resolveCommit&#x27;).never();
const ne = nock(apiUrl)
  .get(&#x60;/api/projects/status/gitHub/${testProject}&#x60;)
  .query(true)
  .reply(
    200,
    apiResponses.getStatusBadge(testStatus),
    {&#x27;Content-Type&#x27;: &#x27;image/svg+xml&#x27;}
  );
appveyorStatus.getStatus((err, status) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(status, testStatus);
  ne.done();
  done();
});</code></pre></dd>
            <dt>throws TypeError for non-function callback</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; { appveyorStatus.getStatus(options, true); },
  TypeError
);</code></pre></dd>
            <dt>rejects non-object options with TypeError</dt>
            <dd><pre><code>appveyorStatus.getStatus(true).then(
        sinon.mock().never(),
        (err) =&#x3E; {
          assert.instanceOf(err, TypeError);
          assert.match(err.message, /\boptions\b/);
        }
      )</code></pre></dd>
            <dt>rejects project and repo with Error</dt>
            <dd><pre><code>options.project = &#x27;foo/bar&#x27;;
options.repo = &#x27;.&#x27;;
return appveyorStatus.getStatus(options).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.instanceOf(err, Error);
    assert.match(err.message, /\bproject\b/);
    assert.match(err.message, /\brepo\b/);
  }
);</code></pre></dd>
            <dt>rejects project and statusBadgeId with Error</dt>
            <dd><pre><code>options.project = &#x27;foo/bar&#x27;;
options.statusBadgeId = &#x27;abcde&#x27;;
return appveyorStatus.getStatus(options).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.instanceOf(err, Error);
    assert.match(err.message, /\bproject\b/);
    assert.match(err.message, /\bstatusBadgeId\b/);
  }
);</code></pre></dd>
            <dt>rejects repo and statusBadgeId with Error</dt>
            <dd><pre><code>options.repo = &#x27;.&#x27;;
options.statusBadgeId = &#x27;abcde&#x27;;
return appveyorStatus.getStatus(options).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.instanceOf(err, Error);
    assert.match(err.message, /\brepo\b/);
    assert.match(err.message, /\bstatusBadgeId\b/);
  }
);</code></pre></dd>
            <dt>rejects project and webhookId with Error</dt>
            <dd><pre><code>options.project = &#x27;foo/bar&#x27;;
options.webhookId = &#x27;abcde&#x27;;
return appveyorStatus.getStatus(options).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.instanceOf(err, Error);
    assert.match(err.message, /\bproject\b/);
    assert.match(err.message, /\bwebhookId\b/);
  }
);</code></pre></dd>
            <dt>rejects repo and webhookId with Error</dt>
            <dd><pre><code>options.repo = &#x27;.&#x27;;
options.webhookId = &#x27;abcde&#x27;;
return appveyorStatus.getStatus(options).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.instanceOf(err, Error);
    assert.match(err.message, /\brepo\b/);
    assert.match(err.message, /\bwebhookId\b/);
  }
);</code></pre></dd>
            <dt>rejects non-Writable err with TypeError</dt>
            <dd><pre><code>appveyorStatus.getStatus({err: new stream.Readable()}).then(
        sinon.mock().never(),
        (err) =&#x3E; {
          assert.instanceOf(err, TypeError);
          assert.match(err.message, /\berr\b/);
        }
      )</code></pre></dd>
            <dt>rejects non-numeric wait with TypeError</dt>
            <dd><pre><code>options.wait = &#x27;forever&#x27;;
return appveyorStatus.getStatus(options).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.instanceOf(err, TypeError);
    assert.match(err.message, /\bwait\b/);
  }
);</code></pre></dd>
            <dt>rejects negative wait with RangeError</dt>
            <dd><pre><code>options.wait = -1;
return appveyorStatus.getStatus(options).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.instanceOf(err, RangeError);
    assert.match(err.message, /\bwait\b/);
  }
);</code></pre></dd>
            <dt>rejects project without accountName with Error</dt>
            <dd><pre><code>options.project = {
  slug: &#x27;foo&#x27;
};
return appveyorStatus.getStatus(options).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.instanceOf(err, Error);
    assert.match(err.message, /\bproject\b/);
    assert.match(err.message, /\baccountName\b/);
  }
);</code></pre></dd>
            <dt>rejects project without slug with Error</dt>
            <dd><pre><code>options.project = {
  accountName: &#x27;foo&#x27;
};
return appveyorStatus.getStatus(options).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.instanceOf(err, Error);
    assert.match(err.message, /\bproject\b/);
    assert.match(err.message, /\bslug\b/);
  }
);</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>appveyor-status command</h1>
      <dl>
        <dt>returns undefined when called with a function</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once()
  .withArgs(
    match.object,
    match.func
  );
const result = appveyorStatusCmd(RUNTIME_ARGS, sinon.mock().never());
appveyorStatusMock.verify();
assert.strictEqual(result, undefined);</code></pre></dd>
        <dt>prints error and exits for --badge</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for -B</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --badge foo as match(statusBadgeId: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -B foo as match(statusBadgeId: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --branch as match(branch: true)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -b as match(branch: true)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --branch foo as match(branch: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -b foo as match(branch: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets  as match(color: false)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --color as match(color: true)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --no-color as match(color: false)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --commit as match(commit: HEAD)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -c as match(commit: HEAD)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --commit foo as match(commit: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --commit 123 as match(commit: 123)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -c foo as match(commit: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for --help</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for -h</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for -?</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for --project</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for -p</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --project foo as match(project: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -p foo as match(project: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --quiet as match(verbosity: -1)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -q as match(verbosity: -1)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -qq as match(verbosity: -2)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --quiet -q as match(verbosity: -2)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for --repo</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for -r</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --repo foo as match(repo: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -r foo as match(repo: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for --token</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for -t</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets  as match(token: env-token)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --token foo as match(token: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -t foo as match(token: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for --token-file</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for -T</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --token-file /home/kevin/src/node-projects/appveyor-status/test-data/token.txt as match(token: file-token)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -T /home/kevin/src/node-projects/appveyor-status/test-data/token.txt as match(token: file-token)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for --token-file badfile</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for -T badfile</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --verbose as match(verbosity: 1)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -v as match(verbosity: 1)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -vv as match(verbosity: 2)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --verbose -v as match(verbosity: 2)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --wait as match(wait: Infinity)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -w as match(wait: Infinity)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --wait 10 as match(wait: 10000)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -w 10 as match(wait: 10000)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for --wait foo</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for -w foo</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for --webhook</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for -W</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets --webhook foo as match(webhookId: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -W foo as match(webhookId: foo)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for -t foo -T bar</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -q -v as match(verbosity: 0)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -v -q as match(verbosity: 0)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -v -q -v as match(verbosity: 1)</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    expectObj,
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for --version</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for -V</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>prints error and exits for foo</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const allArgs = RUNTIME_ARGS.concat(args);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  if (expectOutMsg instanceof RegExp) {
    assert.match(String(options.out.read()), expectOutMsg);
  } else {
    assert.strictEqual(options.out.read(), expectOutMsg);
  }
  if (expectErrMsg instanceof RegExp) {
    assert.match(String(options.err.read()), expectErrMsg);
  } else {
    assert.strictEqual(options.err.read(), expectErrMsg);
  }
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>interprets -T - as reading token from stdin</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).once()
  .withArgs(
    match({token: &#x27;file-token&#x27;}),
    match.func
  )
  .yields(null, &#x27;success&#x27;);
const allArgs = RUNTIME_ARGS.concat(&#x27;-T&#x27;, &#x27;-&#x27;);
options.in = fs.createReadStream(TEST_TOKEN_PATH);
appveyorStatusCmd(allArgs, options, (err) =&#x3E; {
  assert.ifError(err);
  appveyorStatusMock.verify();
  done();
});</code></pre></dd>
        <dt>exits with code 2 for build cancelled</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});</code></pre></dd>
        <dt>exits with code 2 for build cancelling</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});</code></pre></dd>
        <dt>exits with code 2 for build failed</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});</code></pre></dd>
        <dt>exits with code 2 for build queued</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});</code></pre></dd>
        <dt>exits with code 2 for build running</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});</code></pre></dd>
        <dt>exits with code 0 for build success</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});</code></pre></dd>
        <dt>exits with code 2 for build unrecognized</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, expectCode);
  done();
});</code></pre></dd>
        <dt>prints status to stdout by default</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, &#x27;success&#x27;);
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 0);
  assert.strictEqual(
    String(options.out.read()),
    // Be strict about this format since other programs may use it
    &#x27;AppVeyor build status: success\n&#x27;
  );
  assert.strictEqual(options.err.read(), null);
  done();
});</code></pre></dd>
        <dt>prints cancelled in gray to TTY</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
options.out.isTTY = true;
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, status === &#x27;success&#x27; ? 0 : 2);
  const outString = String(options.out.read());
  assert.include(
    outString,
    chalk[colorName](status)
  );
  assert.strictEqual(options.err.read(), null);
  done();
});</code></pre></dd>
        <dt>prints cancelling in gray to TTY</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
options.out.isTTY = true;
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, status === &#x27;success&#x27; ? 0 : 2);
  const outString = String(options.out.read());
  assert.include(
    outString,
    chalk[colorName](status)
  );
  assert.strictEqual(options.err.read(), null);
  done();
});</code></pre></dd>
        <dt>prints failed in red to TTY</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
options.out.isTTY = true;
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, status === &#x27;success&#x27; ? 0 : 2);
  const outString = String(options.out.read());
  assert.include(
    outString,
    chalk[colorName](status)
  );
  assert.strictEqual(options.err.read(), null);
  done();
});</code></pre></dd>
        <dt>prints queued in gray to TTY</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
options.out.isTTY = true;
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, status === &#x27;success&#x27; ? 0 : 2);
  const outString = String(options.out.read());
  assert.include(
    outString,
    chalk[colorName](status)
  );
  assert.strictEqual(options.err.read(), null);
  done();
});</code></pre></dd>
        <dt>prints running in gray to TTY</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
options.out.isTTY = true;
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, status === &#x27;success&#x27; ? 0 : 2);
  const outString = String(options.out.read());
  assert.include(
    outString,
    chalk[colorName](status)
  );
  assert.strictEqual(options.err.read(), null);
  done();
});</code></pre></dd>
        <dt>prints success in green to TTY</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, status);
options.out.isTTY = true;
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, status === &#x27;success&#x27; ? 0 : 2);
  const outString = String(options.out.read());
  assert.include(
    outString,
    chalk[colorName](status)
  );
  assert.strictEqual(options.err.read(), null);
  done();
});</code></pre></dd>
        <dt>-q exits without printing status</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, &#x27;failed&#x27;);
const allArgs = RUNTIME_ARGS.concat(arg);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 2);
  assert.strictEqual(options.out.read(), null);
  assert.strictEqual(options.err.read(), null);
  done();
});</code></pre></dd>
        <dt>--quiet exits without printing status</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, &#x27;failed&#x27;);
const allArgs = RUNTIME_ARGS.concat(arg);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 2);
  assert.strictEqual(options.out.read(), null);
  assert.strictEqual(options.err.read(), null);
  done();
});</code></pre></dd>
        <dt>allows callback errors to propagate</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const errTest = new Error(&#x27;test&#x27;);
let caughtError = false;
let called = false;
// Note:  Chai assert.throws does not accept comparison function like node
try {
  const allArgs = RUNTIME_ARGS.concat([&#x27;foo&#x27;]);
  appveyorStatusCmd(allArgs, options, () =&#x3E; {
    assert(!called, &#x27;callback called exactly once&#x27;);
    called = true;
    throw errTest;
  });
} catch (err) {
  caughtError = true;
  assert.strictEqual(err, errTest);
}
assert(caughtError, &#x27;Missing expected exception.&#x27;);</code></pre></dd>
        <dt>throws for non-function callback</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
assert.throws(
  () =&#x3E; { appveyorStatusCmd(RUNTIME_ARGS, {}, true); },
  TypeError,
  /\bcallback\b/
);</code></pre></dd>
        <dt>can be called without arguments</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once()
  .withArgs(
    match.object,
    match.func
  );
appveyorStatusCmd(null, sinon.mock().never());
appveyorStatusMock.verify();</code></pre></dd>
        <dt>yields TypeError for non-Array-like args</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
appveyorStatusCmd(true, options, (err) =&#x3E; {
  assert.instanceOf(err, TypeError);
  assert.match(err.message, /\bArray\b/);
  done();
});</code></pre></dd>
        <dt>yields RangeError for less than 2 args</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
appveyorStatusCmd([], options, (err) =&#x3E; {
  assert.instanceOf(err, RangeError);
  assert.match(err.message, /\bargs\b/);
  done();
});</code></pre></dd>
        <dt>yields Error for non-object options</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
appveyorStatusCmd(RUNTIME_ARGS, true, (err) =&#x3E; {
  assert.instanceOf(err, TypeError);
  assert.match(err.message, /\boptions\b/);
  done();
});</code></pre></dd>
        <dt>yields Error for non-Readable in</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
appveyorStatusCmd(RUNTIME_ARGS, {in: true}, (err) =&#x3E; {
  assert.instanceOf(err, TypeError);
  assert.match(err.message, /\boptions.in\b/);
  done();
});</code></pre></dd>
        <dt>yields Error for non-Writable out</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const badOptions = {out: new stream.Readable()};
appveyorStatusCmd(RUNTIME_ARGS, badOptions, (err) =&#x3E; {
  assert.instanceOf(err, TypeError);
  assert.match(err.message, /\boptions.out\b/);
  done();
});</code></pre></dd>
        <dt>yields Error for non-Writable err</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const badOptions = {err: new stream.Readable()};
appveyorStatusCmd(RUNTIME_ARGS, badOptions, (err) =&#x3E; {
  assert.instanceOf(err, TypeError);
  assert.match(err.message, /\boptions.err\b/);
  done();
});</code></pre></dd>
        <dt>exit code 1 and prints message on Error</dt>
        <dd><pre><code>const errMsg = &#x27;super duper test error&#x27;;
appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(new Error(errMsg));
appveyorStatusCmd(RUNTIME_ARGS, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 1);
  assert.strictEqual(options.out.read(), null);
  const errString = String(options.err.read());
  assert.include(errString, errMsg);
  done();
});</code></pre></dd>
        <dt>exit code 3 and prints message on CommitMismatchError</dt>
        <dd><pre><code>const testCommit = &#x27;123&#x27;;
const errTest = new CommitMismatchError({
  actual: &#x27;foo&#x27;,
  expected: testCommit
});
appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(errTest);
const allArgs = RUNTIME_ARGS.concat([&#x27;-c&#x27;, testCommit]);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 3);
  assert.strictEqual(options.out.read(), null);
  const errString = String(options.err.read());
  assert.include(errString, errTest.actual);
  assert.include(errString, errTest.expected);
  done();
});</code></pre></dd>
        <dt>CommitMismatchError prints both given and resolved</dt>
        <dd><pre><code>const testCommit = &#x27;123&#x27;;
const testTag = &#x27;tagname&#x27;;
const errTest = new CommitMismatchError({
  actual: &#x27;abc&#x27;,
  expected: testCommit
});
appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(errTest);
const allArgs = RUNTIME_ARGS.concat([&#x27;-c&#x27;, testTag]);
appveyorStatusCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 3);
  assert.strictEqual(options.out.read(), null);
  const errString = String(options.err.read());
  assert.include(errString, errTest.actual);
  assert.include(errString, errTest.expected);
  assert.include(errString, testTag);
  done();
});</code></pre></dd>
        <dt>returns a Promise when called without a function</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func);
const result = appveyorStatusCmd(RUNTIME_ARGS);
assert(result instanceof Promise);</code></pre></dd>
        <dt>returned Promise is resolved with exit code</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;)
  .once().withArgs(match.object, match.func).yields(null, &#x27;success&#x27;);
const result = appveyorStatusCmd(RUNTIME_ARGS, options);
return result.then((code) =&#x3E; {
  assert.strictEqual(code, 0);
});</code></pre></dd>
        <dt>returned Promise is rejected with Error</dt>
        <dd><pre><code>appveyorStatusMock.expects(&#x27;getStatus&#x27;).never();
const result = appveyorStatusCmd(RUNTIME_ARGS, true);
return result.then(
  sinon.mock().never(),
  (err) =&#x3E; { assert.instanceOf(err, TypeError); }
);</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>AmbiguousProjectError</h1>
      <dl>
        <dt>sets .message and .projects from arguments</dt>
        <dd><pre><code>const testMsg = &#x27;test message&#x27;;
const testProjects = [];
const a = new AmbiguousProjectError(testMsg, testProjects);
assert.strictEqual(a.message, testMsg);
assert.strictEqual(a.projects, testProjects);</code></pre></dd>
        <dt>can be instantiated without arguments</dt>
        <dd><pre><code>const a = new AmbiguousProjectError();
assert(a.message, &#x27;has default message&#x27;);
assert.strictEqual(a.projects, undefined);</code></pre></dd>
        <dt>can be instantiated without new</dt>
        <dd><pre><code>const testMsg = &#x27;test message&#x27;;
const testProjects = [];
const a = AmbiguousProjectError(testMsg, testProjects);
assert(a instanceof AmbiguousProjectError);
assert.strictEqual(a.message, testMsg);
assert.strictEqual(a.projects, testProjects);</code></pre></dd>
        <dt>inherits from Error</dt>
        <dd><pre><code>const testMsg = &#x27;test message&#x27;;
const testProjects = [];
const a = new AmbiguousProjectError(testMsg, testProjects);
assert(a instanceof Error);</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>appveyorUtils</h1>
      <dl>
        <section class="suite">
          <h1>.badgeToStatus</h1>
          <dl>
            <dt>extracts success status</dt>
            <dd><pre><code>const badge = apiResponses.getStatusBadge(status);
const result = appveyorUtils.badgeToStatus(badge);
assert.strictEqual(result, status);</code></pre></dd>
            <dt>extracts failed status</dt>
            <dd><pre><code>const badge = apiResponses.getStatusBadge(status);
const result = appveyorUtils.badgeToStatus(badge);
assert.strictEqual(result, status);</code></pre></dd>
            <dt>throws for unrecognized status</dt>
            <dd><pre><code>const badge = apiResponses.getStatusBadge(&#x27;whatever&#x27;);
assert.throws(
  () =&#x3E; { appveyorUtils.badgeToStatus(badge); },
  Error
);</code></pre></dd>
            <dt>throws for ambiguous status</dt>
            <dd><pre><code>const badge = apiResponses.getStatusBadge(&#x27;success failed&#x27;);
assert.throws(
  () =&#x3E; { appveyorUtils.badgeToStatus(badge); },
  Error
);</code></pre></dd>
            <dt>throws for non-string</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; { appveyorUtils.badgeToStatus(null); },
  Error
);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.projectBuildToStatus</h1>
          <dl>
            <dt>returns any status of ProjectBuild</dt>
            <dd><pre><code>const testStatus = &#x27;foo&#x27;;
const projectBuild = apiResponses.getProjectBuild({status: testStatus});
const result = appveyorUtils.projectBuildToStatus(projectBuild);
assert.strictEqual(result, testStatus);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.parseAppveyorRepoUrl</h1>
          <dl>
            <dt>parses bitBucket HTTPS URL</dt>
            <dd><pre><code>const testProject = &#x27;foo/bar&#x27;;
const testUrl = &#x60;https://bitbucket.org/${testProject}.git&#x60;;
deepStrictEqual(
  appveyorUtils.parseAppveyorRepoUrl(testUrl),
  {
    repositoryType: &#x27;bitBucket&#x27;,
    repositoryName: testProject
  }
);</code></pre></dd>
            <dt>parses bitBucket SSH URL</dt>
            <dd><pre><code>const testProject = &#x27;foo/bar&#x27;;
const testUrl = &#x60;git@bitbucket.org:${testProject}.git&#x60;;
deepStrictEqual(
  appveyorUtils.parseAppveyorRepoUrl(testUrl),
  {
    repositoryType: &#x27;bitBucket&#x27;,
    repositoryName: testProject
  }
);</code></pre></dd>
            <dt>parses gitHub HTTPS URL</dt>
            <dd><pre><code>const testProject = &#x27;foo/bar&#x27;;
const testUrl = &#x60;https://github.com/${testProject}.git&#x60;;
deepStrictEqual(
  appveyorUtils.parseAppveyorRepoUrl(testUrl),
  {
    repositoryType: &#x27;gitHub&#x27;,
    repositoryName: testProject
  }
);</code></pre></dd>
            <dt>parses gitHub SSH URL</dt>
            <dd><pre><code>const testProject = &#x27;foo/bar&#x27;;
const testUrl = &#x60;git@github.com:${testProject}.git&#x60;;
deepStrictEqual(
  appveyorUtils.parseAppveyorRepoUrl(testUrl),
  {
    repositoryType: &#x27;gitHub&#x27;,
    repositoryName: testProject
  }
);</code></pre></dd>
            <dt>parses gitLab HTTPS URL</dt>
            <dd><pre><code>const testProject = &#x27;foo/bar&#x27;;
const testUrl = &#x60;https://gitlab.com/${testProject}.git&#x60;;
deepStrictEqual(
  appveyorUtils.parseAppveyorRepoUrl(testUrl),
  {
    repositoryType: &#x27;gitLab&#x27;,
    repositoryName: testProject
  }
);</code></pre></dd>
            <dt>parses gitLab SSH URL</dt>
            <dd><pre><code>const testProject = &#x27;foo/bar&#x27;;
const testUrl = &#x60;git@gitlab.com:${testProject}.git&#x60;;
deepStrictEqual(
  appveyorUtils.parseAppveyorRepoUrl(testUrl),
  {
    repositoryType: &#x27;gitLab&#x27;,
    repositoryName: testProject
  }
);</code></pre></dd>
            <dt>parses vso project git HTTPS URL</dt>
            <dd><pre><code>const testUrl = &#x27;https://kevinoid.visualstudio.com/_git/TestProj&#x27;;
deepStrictEqual(
  appveyorUtils.parseAppveyorRepoUrl(testUrl),
  {
    repositoryType: &#x27;vso&#x27;,
    repositoryName: &#x27;git/kevinoid/TestProj/TestProj&#x27;
  }
);</code></pre></dd>
            <dt>parses vso project git SSH URL</dt>
            <dd><pre><code>const testUrl
  = &#x27;ssh://kevinoid@kevinoid.visualstudio.com:22/_git/TestProj&#x27;;
deepStrictEqual(
  appveyorUtils.parseAppveyorRepoUrl(testUrl),
  {
    repositoryType: &#x27;vso&#x27;,
    repositoryName: &#x27;git/kevinoid/TestProj/TestProj&#x27;
  }
);</code></pre></dd>
            <dt>parses vso sub-project git HTTPS URL</dt>
            <dd><pre><code>const testUrl = &#x27;https://kevinoid.visualstudio.com/TestProj/_git/repo2&#x27;;
deepStrictEqual(
  appveyorUtils.parseAppveyorRepoUrl(testUrl),
  {
    repositoryType: &#x27;vso&#x27;,
    repositoryName: &#x27;git/kevinoid/TestProj/repo2&#x27;
  }
);</code></pre></dd>
            <dt>parses vso sub-project git SSH URL</dt>
            <dd><pre><code>const testUrl
  = &#x27;ssh://kevinoid@kevinoid.visualstudio.com:22/TestProj/_git/repo2&#x27;;
deepStrictEqual(
  appveyorUtils.parseAppveyorRepoUrl(testUrl),
  {
    repositoryType: &#x27;vso&#x27;,
    repositoryName: &#x27;git/kevinoid/TestProj/repo2&#x27;
  }
);</code></pre></dd>
            <dt>returns unknown HTTPS URL</dt>
            <dd><pre><code>const testUrl = &#x27;https://example.com/foo.git&#x27;;
deepStrictEqual(
  appveyorUtils.parseAppveyorRepoUrl(testUrl),
  {repositoryName: testUrl}
);</code></pre></dd>
            <dt>returns unknown SCP-like URL</dt>
            <dd><pre><code>const testUrl = &#x27;user@example.com:foo.git&#x27;;
deepStrictEqual(
  appveyorUtils.parseAppveyorRepoUrl(testUrl),
  {repositoryName: testUrl}
);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.repoUrlToBadgeParams</h1>
          <dl>
            <dt>parses bitBucket HTTPS URL</dt>
            <dd><pre><code>const testAccount = &#x27;foo&#x27;;
const testProject = &#x27;bar&#x27;;
const testUrl
  = &#x60;https://bitbucket.org/${testAccount}/${testProject}.git&#x60;;
deepStrictEqual(
  appveyorUtils.repoUrlToBadgeParams(testUrl),
  {
    badgeRepoProvider: &#x27;bitBucket&#x27;,
    repoAccountName: testAccount,
    repoSlug: testProject
  }
);</code></pre></dd>
            <dt>parses bitBucket SSH URL</dt>
            <dd><pre><code>const testAccount = &#x27;foo&#x27;;
const testProject = &#x27;bar&#x27;;
const testUrl
  = &#x60;git@bitbucket.org:${testAccount}/${testProject}.git&#x60;;
deepStrictEqual(
  appveyorUtils.repoUrlToBadgeParams(testUrl),
  {
    badgeRepoProvider: &#x27;bitBucket&#x27;,
    repoAccountName: testAccount,
    repoSlug: testProject
  }
);</code></pre></dd>
            <dt>throws for bitBucket URL with 3 path parts</dt>
            <dd><pre><code>const testUrl = &#x27;https://bitbucket.org/foo/bar/baz.git&#x27;;
assert.throws(
  () =&#x3E; { appveyorUtils.repoUrlToBadgeParams(testUrl); },
  Error
);</code></pre></dd>
            <dt>parses gitHub HTTPS URL</dt>
            <dd><pre><code>const testAccount = &#x27;foo&#x27;;
const testProject = &#x27;bar&#x27;;
const testUrl
  = &#x60;https://github.com/${testAccount}/${testProject}.git&#x60;;
deepStrictEqual(
  appveyorUtils.repoUrlToBadgeParams(testUrl),
  {
    badgeRepoProvider: &#x27;gitHub&#x27;,
    repoAccountName: testAccount,
    repoSlug: testProject
  }
);</code></pre></dd>
            <dt>parses gitHub SSH URL</dt>
            <dd><pre><code>const testAccount = &#x27;foo&#x27;;
const testProject = &#x27;bar&#x27;;
const testUrl
  = &#x60;git@github.com:${testAccount}/${testProject}.git&#x60;;
deepStrictEqual(
  appveyorUtils.repoUrlToBadgeParams(testUrl),
  {
    badgeRepoProvider: &#x27;gitHub&#x27;,
    repoAccountName: testAccount,
    repoSlug: testProject
  }
);</code></pre></dd>
            <dt>throws for gitLab HTTPS URL</dt>
            <dd><pre><code>const testUrl = &#x27;https://gitlab.com/foo/bar.git&#x27;;
assert.throws(
  () =&#x3E; { appveyorUtils.repoUrlToBadgeParams(testUrl); },
  Error
);</code></pre></dd>
            <dt>throws for gitLab HTTPS URL</dt>
            <dd><pre><code>const testUrl = &#x27;git@gitlab.com:foo/bar.git&#x27;;
assert.throws(
  () =&#x3E; { appveyorUtils.repoUrlToBadgeParams(testUrl); },
  Error
);</code></pre></dd>
            <dt>throws for vso HTTPS URL</dt>
            <dd><pre><code>const testUrl = &#x27;https://kevinoid.visualstudio.com/_git/TestProj&#x27;;
assert.throws(
  () =&#x3E; { appveyorUtils.repoUrlToBadgeParams(testUrl); },
  Error
);</code></pre></dd>
            <dt>throws for vso SSH URL</dt>
            <dd><pre><code>const testUrl
  = &#x27;ssh://kevinoid@kevinoid.visualstudio.com:22/_git/TestProj&#x27;;
assert.throws(
  () =&#x3E; { appveyorUtils.repoUrlToBadgeParams(testUrl); },
  Error
);</code></pre></dd>
            <dt>throws for other git HTTPS URLs</dt>
            <dd><pre><code>const testUrl = &#x27;https://example.com/foo.git&#x27;;
assert.throws(
  () =&#x3E; { appveyorUtils.repoUrlToBadgeParams(testUrl); },
  Error
);</code></pre></dd>
            <dt>returns unknown git SSH URL</dt>
            <dd><pre><code>const testUrl = &#x27;user@example.com:foo.git&#x27;;
assert.throws(
  () =&#x3E; { appveyorUtils.repoUrlToBadgeParams(testUrl); },
  Error
);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.projectFromString</h1>
          <dl>
            <dt>splits account name and slug to object</dt>
            <dd><pre><code>const accountName = &#x27;foo&#x27;;
const slug = &#x27;bar&#x27;;
deepStrictEqual(
  appveyorUtils.projectFromString(&#x60;${accountName}/${slug}&#x60;),
  {
    accountName,
    slug
  }
);</code></pre></dd>
            <dt>throws for string with 1 path part</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; { appveyorUtils.projectFromString(&#x27;foo&#x27;); },
  Error
);</code></pre></dd>
            <dt>throws for string with 3 path part</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; { appveyorUtils.projectFromString(&#x27;foo/bar/baz&#x27;); },
  Error
);</code></pre></dd>
            <dt>throws for non-string</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; { appveyorUtils.projectFromString(null); },
  Error
);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.projectToString</h1>
          <dl>
            <dt>joins account name and slug</dt>
            <dd><pre><code>const testProj = {
  accountName: &#x27;foo&#x27;,
  slug: &#x27;bar&#x27;
};
deepStrictEqual(
  appveyorUtils.projectToString(testProj),
  &#x27;foo/bar&#x27;
);</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>CommitMismatchError</h1>
      <dl>
        <dt>sets .actual and .expected from arguments</dt>
        <dd><pre><code>const testOptions = {
  actual: &#x27;abc&#x27;,
  expected: &#x27;123&#x27;
};
const err = new CommitMismatchError(testOptions);
assert.strictEqual(err.actual, testOptions.actual);
assert.strictEqual(err.expected, testOptions.expected);
assert.strictEqual(err.operator, &#x27;===&#x27;);
assert(
  err.message.indexOf(testOptions.actual) &#x3E;= 0,
  &#x27;constructs message with actual&#x27;
);
assert(
  err.message.indexOf(testOptions.expected) &#x3E;= 0,
  &#x27;constructs message with expected&#x27;
);</code></pre></dd>
        <dt>can set .message from arguments</dt>
        <dd><pre><code>const testOptions = {
  actual: &#x27;abc&#x27;,
  expected: &#x27;123&#x27;,
  message: &#x27;test&#x27;
};
const err = new CommitMismatchError(testOptions);
assert.strictEqual(err.actual, testOptions.actual);
assert.strictEqual(err.expected, testOptions.expected);
assert.strictEqual(err.operator, &#x27;===&#x27;);
assert.strictEqual(err.message, testOptions.message);</code></pre></dd>
        <dt>can be instantiated without new</dt>
        <dd><pre><code>const testOptions = {
  actual: &#x27;abc&#x27;,
  expected: &#x27;123&#x27;
};
const err = CommitMismatchError(testOptions);
assert.strictEqual(err.actual, testOptions.actual);
assert.strictEqual(err.expected, testOptions.expected);
assert.strictEqual(err.operator, &#x27;===&#x27;);
assert(
  err.message.indexOf(testOptions.actual) &#x3E;= 0,
  &#x27;constructs message with actual&#x27;
);
assert(
  err.message.indexOf(testOptions.expected) &#x3E;= 0,
  &#x27;constructs message with expected&#x27;
);</code></pre></dd>
        <dt>inherits from Error</dt>
        <dd><pre><code>const testOptions = {
  actual: &#x27;abc&#x27;,
  expected: &#x27;123&#x27;
};
const err = new CommitMismatchError(testOptions);
assert(err instanceof Error);</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>execFileOut</h1>
      <dl>
        <dt>returns a Promise with stdout</dt>
        <dd><pre><code>const testOut = &#x27;stdout content&#x27;;
const testArgs = [&#x27;-e&#x27;, makeScript(testOut)];
return execFileOut(process.execPath, testArgs)
  .then((stdout) =&#x3E; {
    assert.strictEqual(stdout, testOut);
  });</code></pre></dd>
        <dt>returns a Promise with stdout as Buffer</dt>
        <dd><pre><code>const testOut = &#x27;stdout content&#x27;;
const testArgs = [&#x27;-e&#x27;, makeScript(testOut)];
const options = {encoding: &#x27;buffer&#x27;};
return execFileOut(process.execPath, testArgs, options)
  .then((stdout) =&#x3E; {
    deepStrictEqual(stdout, Buffer.from(testOut));
  });</code></pre></dd>
        <dt>rejects Promise with Error for non-0 exit code</dt>
        <dd><pre><code>const testOut = &#x27;stdout content&#x27;;
const testCode = 2;
const testArgs = [&#x27;-e&#x27;, makeScript(testOut, null, testCode)];
return execFileOut(process.execPath, testArgs).then(
  neverCalled,
  (err) =&#x3E; {
    assert.strictEqual(
      err.cmd,
      [process.execPath].concat(testArgs).join(&#x27; &#x27;)
    );
    assert.strictEqual(err.code, testCode);
    assert.strictEqual(err.stderr, &#x27;&#x27;);
    assert.strictEqual(err.stdout, testOut);
  }
);</code></pre></dd>
        <dt>rejects Promise with Error for non-empty stderr</dt>
        <dd><pre><code>const testOut = &#x27;stdout content&#x27;;
const testErr = &#x27;stderr content&#x27;;
const testArgs = [&#x27;-e&#x27;, makeScript(testOut, testErr)];
return execFileOut(process.execPath, testArgs).then(
  neverCalled,
  (err) =&#x3E; {
    assert(err.message.indexOf(testErr) &#x3E;= 0, &#x27;stderr is in message&#x27;);
    assert.strictEqual(
      err.cmd,
      [process.execPath].concat(testArgs).join(&#x27; &#x27;)
    );
    assert.strictEqual(err.code, 0);
    assert.strictEqual(err.stderr, testErr);
    assert.strictEqual(err.stdout, testOut);
  }
);</code></pre></dd>
        <dt>rejects Promise with Error for non-empty stderr Buffer</dt>
        <dd><pre><code>const testOut = &#x27;stdout content&#x27;;
const testErr = &#x27;stderr content&#x27;;
const testArgs = [&#x27;-e&#x27;, makeScript(testOut, testErr)];
const options = {encoding: &#x27;buffer&#x27;};
return execFileOut(process.execPath, testArgs, options).then(
  neverCalled,
  (err) =&#x3E; {
    assert(err.message.indexOf(testErr) &#x3E;= 0, &#x27;stderr is in message&#x27;);
    assert.strictEqual(
      err.cmd,
      [process.execPath].concat(testArgs).join(&#x27; &#x27;)
    );
    assert.strictEqual(err.code, 0);
    deepStrictEqual(err.stderr, Buffer.from(testErr));
    deepStrictEqual(err.stdout, Buffer.from(testOut));
  }
);</code></pre></dd>
        <dt>does not reject stderr with only whitespace</dt>
        <dd><pre><code>const testOut = &#x27;stdout content&#x27;;
const testErr = &#x27;\n\t\t  \n&#x27;;
const testArgs = [&#x27;-e&#x27;, makeScript(testOut, testErr)];
return execFileOut(process.execPath, testArgs)
  .then((stdout) =&#x3E; {
    assert.strictEqual(stdout, testOut);
  });</code></pre></dd>
        <dt>closes stdin to prevent hanging</dt>
        <dd><pre><code>execFileOut(process.execPath)</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>gitUtils</h1>
      <dl>
        <section class="suite">
          <h1>.getBranch</h1>
          <dl>
            <dt>resolves master on master</dt>
            <dd><pre><code>gitUtils.getBranch(options)
      .then((branch) =&#x3E; {
        assert.strictEqual(branch, &#x27;master&#x27;);
      })</code></pre></dd>
            <dt>resolves branch1 on branch1</dt>
            <dd><pre><code>execFileOut(&#x27;git&#x27;, [&#x27;checkout&#x27;, &#x27;-q&#x27;, &#x27;branch1&#x27;], options)
        .then(() =&#x3E; gitUtils.getBranch(options))
        .then((branch) =&#x3E; {
          assert.strictEqual(branch, &#x27;branch1&#x27;);
        })</code></pre></dd>
            <dt>rejects with Error not on branch</dt>
            <dd><pre><code>execFileOut(&#x27;git&#x27;, [&#x27;checkout&#x27;, &#x27;-q&#x27;, &#x27;HEAD^&#x27;], options)
        .then(() =&#x3E; gitUtils.getBranch(options))
        .then(
          neverCalled,
          (err) =&#x3E; {
            assert.instanceOf(err, Error);
            assert.match(err.message, /branch/i);
          }
        )</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.getRemote</h1>
          <dl>
            <dt>resolves master to origin</dt>
            <dd><pre><code>gitUtils.getRemote(branch, options).then((result) =&#x3E; {
          assert.strictEqual(result, remote);
        })</code></pre></dd>
            <dt>resolves branch1 to remote1</dt>
            <dd><pre><code>gitUtils.getRemote(branch, options).then((result) =&#x3E; {
          assert.strictEqual(result, remote);
        })</code></pre></dd>
            <dt>resolves branch2 to remote2</dt>
            <dd><pre><code>gitUtils.getRemote(branch, options).then((result) =&#x3E; {
          assert.strictEqual(result, remote);
        })</code></pre></dd>
            <dt>resolves branchnourl to nourl</dt>
            <dd><pre><code>gitUtils.getRemote(branch, options).then((result) =&#x3E; {
          assert.strictEqual(result, remote);
        })</code></pre></dd>
            <dt>resolves branchnotslug to notslug</dt>
            <dd><pre><code>gitUtils.getRemote(branch, options).then((result) =&#x3E; {
          assert.strictEqual(result, remote);
        })</code></pre></dd>
            <dt>rejects branch without remote with Error</dt>
            <dd><pre><code>gitUtils.getRemote(&#x27;branchnoremote&#x27;, options).then(
        neverCalled,
        (err) =&#x3E; {
          assert.instanceOf(err, Error);
        }
      )</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.getRemoteUrl</h1>
          <dl>
            <dt>resolves notslug to foo</dt>
            <dd><pre><code>gitUtils.getRemoteUrl(remoteName, options)
          .then((resultUrl) =&#x3E; {
            assert.strictEqual(resultUrl, remoteUrl);
          })</code></pre></dd>
            <dt>resolves origin to https://github.com/owner/repo</dt>
            <dd><pre><code>gitUtils.getRemoteUrl(remoteName, options)
          .then((resultUrl) =&#x3E; {
            assert.strictEqual(resultUrl, remoteUrl);
          })</code></pre></dd>
            <dt>resolves remote1 to git@github.com:owner1/repo1.git</dt>
            <dd><pre><code>gitUtils.getRemoteUrl(remoteName, options)
          .then((resultUrl) =&#x3E; {
            assert.strictEqual(resultUrl, remoteUrl);
          })</code></pre></dd>
            <dt>resolves remote2 to https://github.com/owner2/repo2.git</dt>
            <dd><pre><code>gitUtils.getRemoteUrl(remoteName, options)
          .then((resultUrl) =&#x3E; {
            assert.strictEqual(resultUrl, remoteUrl);
          })</code></pre></dd>
            <dt>rejects invalid remote with Error</dt>
            <dd><pre><code>gitUtils.getRemoteUrl(&#x27;invalidremote&#x27;, options).then(
        neverCalled,
        (err) =&#x3E; {
          assert.instanceOf(err, Error);
        }
      )</code></pre></dd>
            <dt>uses ls-remote default for unspecified remote</dt>
            <dd><pre><code>gitUtils.getRemoteUrl(null, options)
        .then((resultUrl) =&#x3E; {
          assert.strictEqual(resultUrl, REMOTES.origin);
        })</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.gitUrlIsLocalNotSsh</h1>
          <dl>
            <dt>. is true</dt>
            <dd><pre><code>assert.strictEqual(
  gitUtils.gitUrlIsLocalNotSsh(testCase.url),
  testCase.result
);</code></pre></dd>
            <dt>/foo/bar is true</dt>
            <dd><pre><code>assert.strictEqual(
  gitUtils.gitUrlIsLocalNotSsh(testCase.url),
  testCase.result
);</code></pre></dd>
            <dt>http://example.com is false</dt>
            <dd><pre><code>assert.strictEqual(
  gitUtils.gitUrlIsLocalNotSsh(testCase.url),
  testCase.result
);</code></pre></dd>
            <dt>git://example.com is false</dt>
            <dd><pre><code>assert.strictEqual(
  gitUtils.gitUrlIsLocalNotSsh(testCase.url),
  testCase.result
);</code></pre></dd>
            <dt>git@example.com:foo is false</dt>
            <dd><pre><code>assert.strictEqual(
  gitUtils.gitUrlIsLocalNotSsh(testCase.url),
  testCase.result
);</code></pre></dd>
            <dt>file:///foo/bar is false</dt>
            <dd><pre><code>assert.strictEqual(
  gitUtils.gitUrlIsLocalNotSsh(testCase.url),
  testCase.result
);</code></pre></dd>
            <dt>/foo:bar is true</dt>
            <dd><pre><code>assert.strictEqual(
  gitUtils.gitUrlIsLocalNotSsh(testCase.url),
  testCase.result
);</code></pre></dd>
            <dt>foo:bar is false</dt>
            <dd><pre><code>assert.strictEqual(
  gitUtils.gitUrlIsLocalNotSsh(testCase.url),
  testCase.result
);</code></pre></dd>
            <dt>C:/foo is false on non-Windows</dt>
            <dd><pre><code>assert.strictEqual(
  gitUtils.gitUrlIsLocalNotSsh(drivePath),
  false
);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.parseGitUrl</h1>
          <dl>
            <dt>parses http: like url module</dt>
            <dd><pre><code>const testUrl = &#x27;http://user@example.com/foo/bar&#x27;;
deepStrictEqual(
  gitUtils.parseGitUrl(testUrl),
  Object.assign(url.parse(testUrl), {helper: undefined})
);</code></pre></dd>
            <dt>parses git: like url module</dt>
            <dd><pre><code>const testUrl = &#x27;git://user@example.com/foo/bar&#x27;;
deepStrictEqual(
  gitUtils.parseGitUrl(testUrl),
  Object.assign(url.parse(testUrl), {helper: undefined})
);</code></pre></dd>
            <dt>parses SCP-like URL like ssh: URL</dt>
            <dd><pre><code>const testUrl = &#x27;user@example.com:foo/bar.git&#x27;;
deepStrictEqual(
  gitUtils.parseGitUrl(testUrl),
  Object.assign(
    url.parse(&#x27;ssh://user@example.com/foo/bar.git&#x27;),
    {helper: undefined}
  )
);</code></pre></dd>
            <dt>parses absolute path like file:// URL</dt>
            <dd><pre><code>const testPath = path.resolve(path.join(&#x27;foo&#x27;, &#x27;bar&#x27;));
deepStrictEqual(
  gitUtils.parseGitUrl(testPath),
  Object.assign(url.parse(fileUrl(testPath)), {helper: undefined})
);</code></pre></dd>
            <dt>parses relative path like file:// URL</dt>
            <dd><pre><code>const testPath = path.join(&#x27;foo&#x27;, &#x27;bar&#x27;);
deepStrictEqual(
  gitUtils.parseGitUrl(testPath),
  Object.assign(url.parse(fileUrl(testPath)), {helper: undefined})
);</code></pre></dd>
            <dt>parses Windows path like URL on non-Windows</dt>
            <dd><pre><code>const testPath = &#x27;C:\\foo\\bar&#x27;;
deepStrictEqual(
  gitUtils.parseGitUrl(testPath),
  Object.assign(url.parse(testPath), {helper: undefined})
);</code></pre></dd>
            <dt>adds helper property for transport helper</dt>
            <dd><pre><code>const testUrl = &#x27;myhelper::user@example.com:foo/bar.git&#x27;;
deepStrictEqual(
  gitUtils.parseGitUrl(testUrl),
  Object.assign(
    url.parse(&#x27;ssh://user@example.com/foo/bar.git&#x27;),
    {helper: &#x27;myhelper&#x27;}
  )
);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.resolveCommit</h1>
          <dl>
            <dt>can resolve the hash of HEAD</dt>
            <dd><pre><code>gitUtils.resolveCommit(&#x27;HEAD&#x27;, options).then((hash) =&#x3E; {
        assert.match(hash, /^[a-fA-F0-9]{40}$/);
        headHash = hash;
      })</code></pre></dd>
            <dt>can resolve a hash to itself</dt>
            <dd><pre><code>gitUtils.resolveCommit(headHash, options).then((hash) =&#x3E; {
        assert.strictEqual(hash, headHash);
      })</code></pre></dd>
            <dt>can resolve branch name to commit hash</dt>
            <dd><pre><code>const branchName = Object.keys(BRANCH_REMOTES)[0];
return gitUtils.resolveCommit(branchName, options).then((hash) =&#x3E; {
  assert.match(hash, /^[a-fA-F0-9]{40}$/);
});</code></pre></dd>
            <dt>can resolve tag name to commit hash</dt>
            <dd><pre><code>gitUtils.resolveCommit(TAGS[0], options).then((hash) =&#x3E; {
        assert.match(hash, /^[a-fA-F0-9]{40}$/);
      })</code></pre></dd>
            <dt>rejects with Error for unresolvable name</dt>
            <dd><pre><code>gitUtils.resolveCommit(&#x27;notabranch&#x27;, options).then(
        neverCalled,
        (err) =&#x3E; {
          assert(err instanceof Error);
        }
      )</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
  </div><!-- .container -->

  <script type="text/javascript" src="https://cdn.jsdelivr.net/jquery/2.2.1/jquery.min.js"></script>
  <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/highlight.js/9.1.0/highlight.min.js"></script>
  <script type="text/javascript">//<![CDATA[
'use strict';
// Adjust the nested heading level to match depth
$('section section h1').each(function() {
  var $this = $(this);
  var depth = Math.min($this.parents('section').length, 6);
  // http://stackoverflow.com/a/30059450/503410
  $this.wrapInner(document.createElement('h' + depth)).children().unwrap();
});

// Make the tests collapsible
var testNum = 0;
$('dt + dd')
  .addClass('collapse')
  .attr('role', 'tabpanel')
  .attr('aria-expanded', 'false')
  .each(function() {
    var $this = $(this);
    var $dt = $this.prev();

    ++testNum;
    var id = 'test' + testNum;
    var idDt = id + '-title';
    var idDd = id + '-desc';

    $dt.attr('id', idDt);
    $this.attr('id', idDd);

    $dt.wrapInner('<a role="button" data-toggle="collapse" href="#' + idDd +
        '" aria-expanded="false" aria-controls="' + idDd + '"></a>')
      .children()
      .collapse();
  });

// Enable syntax highlighting for the code (which is all JavaScript)
hljs.configure({languages: ['javascript']});
hljs.initHighlighting();
//]]></script>
</body>
</html>
